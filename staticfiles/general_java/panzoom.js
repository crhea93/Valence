!(function(Q) {
  var U = window.webpackHotUpdate
  window.webpackHotUpdate = function(Q, F) {
    !(function(Q, U) {
      if (!C[Q] || !o[Q]) return
      for (var F in ((o[Q] = !1), U)) Object.prototype.hasOwnProperty.call(U, F) && (I[F] = U[F])
      0 == --b && 0 === a && S()
    })(Q, F),
      U && U(Q, F)
  }
  var F,
    B = !0,
    n = '2831a7098f5bc79d781b',
    s = {},
    e = [],
    t = []
  function l(Q) {
    var U = V[Q]
    if (!U) return R
    var B = function(B) {
        return (
          U.hot.active
            ? (V[B] ? -1 === V[B].parents.indexOf(Q) && V[B].parents.push(Q) : ((e = [Q]), (F = B)),
              -1 === U.children.indexOf(B) && U.children.push(B))
            : (console.warn('[HMR] unexpected require(' + B + ') from disposed module ' + Q),
              (e = [])),
          R(B)
        )
      },
      n = function(Q) {
        return {
          configurable: !0,
          enumerable: !0,
          get: function() {
            return R[Q]
          },
          set: function(U) {
            R[Q] = U
          }
        }
      }
    for (var s in R)
      Object.prototype.hasOwnProperty.call(R, s) &&
        'e' !== s &&
        't' !== s &&
        Object.defineProperty(B, s, n(s))
    return (
      (B.e = function(Q) {
        return (
          'ready' === g && i('prepare'),
          a++,
          R.e(Q).then(U, function(Q) {
            throw (U(), Q)
          })
        )
        function U() {
          a--, 'prepare' === g && (L[Q] || y(Q), 0 === a && 0 === b && S())
        }
      }),
      (B.t = function(Q, U) {
        return 1 & U && (Q = B(Q)), R.t(Q, -2 & U)
      }),
      B
    )
  }
  function r(Q) {
    var U = {
      _acceptedDependencies: {},
      _declinedDependencies: {},
      _selfAccepted: !1,
      _selfDeclined: !1,
      _disposeHandlers: [],
      _main: F !== Q,
      active: !0,
      accept: function(Q, F) {
        if (void 0 === Q) U._selfAccepted = !0
        else if ('function' == typeof Q) U._selfAccepted = Q
        else if ('object' == typeof Q)
          for (var B = 0; B < Q.length; B++) U._acceptedDependencies[Q[B]] = F || function() {}
        else U._acceptedDependencies[Q] = F || function() {}
      },
      decline: function(Q) {
        if (void 0 === Q) U._selfDeclined = !0
        else if ('object' == typeof Q)
          for (var F = 0; F < Q.length; F++) U._declinedDependencies[Q[F]] = !0
        else U._declinedDependencies[Q] = !0
      },
      dispose: function(Q) {
        U._disposeHandlers.push(Q)
      },
      addDisposeHandler: function(Q) {
        U._disposeHandlers.push(Q)
      },
      removeDisposeHandler: function(Q) {
        var F = U._disposeHandlers.indexOf(Q)
        F >= 0 && U._disposeHandlers.splice(F, 1)
      },
      check: G,
      apply: E,
      status: function(Q) {
        if (!Q) return g
        c.push(Q)
      },
      addStatusHandler: function(Q) {
        c.push(Q)
      },
      removeStatusHandler: function(Q) {
        var U = c.indexOf(Q)
        U >= 0 && c.splice(U, 1)
      },
      data: s[Q]
    }
    return (F = void 0), U
  }
  var c = [],
    g = 'idle'
  function i(Q) {
    g = Q
    for (var U = 0; U < c.length; U++) c[U].call(null, Q)
  }
  var x,
    I,
    d,
    b = 0,
    a = 0,
    L = {},
    o = {},
    C = {}
  function u(Q) {
    return +Q + '' === Q ? +Q : Q
  }
  function G(Q) {
    if ('idle' !== g) throw new Error('check() is only allowed in idle status')
    return (
      (B = Q),
      i('check'),
      ((U = 1e4),
      (U = U || 1e4),
      new Promise(function(Q, F) {
        if ('undefined' == typeof XMLHttpRequest) return F(new Error('No browser support'))
        try {
          var B = new XMLHttpRequest(),
            s = R.p + '' + n + '.hot-update.json'
          B.open('GET', s, !0), (B.timeout = U), B.send(null)
        } catch (Q) {
          return F(Q)
        }
        B.onreadystatechange = function() {
          if (4 === B.readyState)
            if (0 === B.status) F(new Error('Manifest request to ' + s + ' timed out.'))
            else if (404 === B.status) Q()
            else if (200 !== B.status && 304 !== B.status)
              F(new Error('Manifest request to ' + s + ' failed.'))
            else {
              try {
                var U = JSON.parse(B.responseText)
              } catch (Q) {
                return void F(Q)
              }
              Q(U)
            }
        }
      })).then(function(Q) {
        if (!Q) return i('idle'), null
        ;(o = {}), (L = {}), (C = Q.c), (d = Q.h), i('prepare')
        var U = new Promise(function(Q, U) {
          x = { resolve: Q, reject: U }
        })
        I = {}
        return y(1), 'prepare' === g && 0 === a && 0 === b && S(), U
      })
    )
    var U
  }
  function y(Q) {
    C[Q]
      ? ((o[Q] = !0),
        b++,
        (function(Q) {
          var U = document.createElement('script')
          ;(U.charset = 'utf-8'),
            (U.src = R.p + '' + Q + '.' + n + '.hot-update.js'),
            document.head.appendChild(U)
        })(Q))
      : (L[Q] = !0)
  }
  function S() {
    i('ready')
    var Q = x
    if (((x = null), Q))
      if (B)
        Promise.resolve()
          .then(function() {
            return E(B)
          })
          .then(
            function(U) {
              Q.resolve(U)
            },
            function(U) {
              Q.reject(U)
            }
          )
      else {
        var U = []
        for (var F in I) Object.prototype.hasOwnProperty.call(I, F) && U.push(u(F))
        Q.resolve(U)
      }
  }
  function E(U) {
    if ('ready' !== g) throw new Error('apply() is only allowed in ready status')
    var F, B, t, l, r
    function c(Q) {
      for (
        var U = [Q],
          F = {},
          B = U.map(function(Q) {
            return { chain: [Q], id: Q }
          });
        B.length > 0;

      ) {
        var n = B.pop(),
          s = n.id,
          e = n.chain
        if ((l = V[s]) && !l.hot._selfAccepted) {
          if (l.hot._selfDeclined) return { type: 'self-declined', chain: e, moduleId: s }
          if (l.hot._main) return { type: 'unaccepted', chain: e, moduleId: s }
          for (var t = 0; t < l.parents.length; t++) {
            var r = l.parents[t],
              c = V[r]
            if (c) {
              if (c.hot._declinedDependencies[s])
                return { type: 'declined', chain: e.concat([r]), moduleId: s, parentId: r }
              ;-1 === U.indexOf(r) &&
                (c.hot._acceptedDependencies[s]
                  ? (F[r] || (F[r] = []), x(F[r], [s]))
                  : (delete F[r], U.push(r), B.push({ chain: e.concat([r]), id: r })))
            }
          }
        }
      }
      return { type: 'accepted', moduleId: Q, outdatedModules: U, outdatedDependencies: F }
    }
    function x(Q, U) {
      for (var F = 0; F < U.length; F++) {
        var B = U[F]
        ;-1 === Q.indexOf(B) && Q.push(B)
      }
    }
    U = U || {}
    var b = {},
      a = [],
      L = {},
      o = function() {
        console.warn('[HMR] unexpected require(' + y.moduleId + ') to disposed module')
      }
    for (var G in I)
      if (Object.prototype.hasOwnProperty.call(I, G)) {
        var y
        r = u(G)
        var S = !1,
          E = !1,
          m = !1,
          Z = ''
        switch (
          ((y = I[G] ? c(r) : { type: 'disposed', moduleId: G }).chain &&
            (Z = '\nUpdate propagation: ' + y.chain.join(' -> ')),
          y.type)
        ) {
          case 'self-declined':
            U.onDeclined && U.onDeclined(y),
              U.ignoreDeclined ||
                (S = new Error('Aborted because of self decline: ' + y.moduleId + Z))
            break
          case 'declined':
            U.onDeclined && U.onDeclined(y),
              U.ignoreDeclined ||
                (S = new Error(
                  'Aborted because of declined dependency: ' + y.moduleId + ' in ' + y.parentId + Z
                ))
            break
          case 'unaccepted':
            U.onUnaccepted && U.onUnaccepted(y),
              U.ignoreUnaccepted || (S = new Error('Aborted because ' + r + ' is not accepted' + Z))
            break
          case 'accepted':
            U.onAccepted && U.onAccepted(y), (E = !0)
            break
          case 'disposed':
            U.onDisposed && U.onDisposed(y), (m = !0)
            break
          default:
            throw new Error('Unexception type ' + y.type)
        }
        if (S) return i('abort'), Promise.reject(S)
        if (E)
          for (r in ((L[r] = I[r]), x(a, y.outdatedModules), y.outdatedDependencies))
            Object.prototype.hasOwnProperty.call(y.outdatedDependencies, r) &&
              (b[r] || (b[r] = []), x(b[r], y.outdatedDependencies[r]))
        m && (x(a, [y.moduleId]), (L[r] = o))
      }
    var N,
      D = []
    for (B = 0; B < a.length; B++)
      (r = a[B]),
        V[r] &&
          V[r].hot._selfAccepted &&
          L[r] !== o &&
          D.push({ module: r, errorHandler: V[r].hot._selfAccepted })
    i('dispose'),
      Object.keys(C).forEach(function(Q) {
        !1 === C[Q] &&
          (function(Q) {
            delete installedChunks[Q]
          })(Q)
      })
    for (var p, W, A = a.slice(); A.length > 0; )
      if (((r = A.pop()), (l = V[r]))) {
        var h = {},
          X = l.hot._disposeHandlers
        for (t = 0; t < X.length; t++) (F = X[t])(h)
        for (
          s[r] = h, l.hot.active = !1, delete V[r], delete b[r], t = 0;
          t < l.children.length;
          t++
        ) {
          var H = V[l.children[t]]
          H && (N = H.parents.indexOf(r)) >= 0 && H.parents.splice(N, 1)
        }
      }
    for (r in b)
      if (Object.prototype.hasOwnProperty.call(b, r) && (l = V[r]))
        for (W = b[r], t = 0; t < W.length; t++)
          (p = W[t]), (N = l.children.indexOf(p)) >= 0 && l.children.splice(N, 1)
    for (r in (i('apply'), (n = d), L)) Object.prototype.hasOwnProperty.call(L, r) && (Q[r] = L[r])
    var v = null
    for (r in b)
      if (Object.prototype.hasOwnProperty.call(b, r) && (l = V[r])) {
        W = b[r]
        var J = []
        for (B = 0; B < W.length; B++)
          if (((p = W[B]), (F = l.hot._acceptedDependencies[p]))) {
            if (-1 !== J.indexOf(F)) continue
            J.push(F)
          }
        for (B = 0; B < J.length; B++) {
          F = J[B]
          try {
            F(W)
          } catch (Q) {
            U.onErrored &&
              U.onErrored({ type: 'accept-errored', moduleId: r, dependencyId: W[B], error: Q }),
              U.ignoreErrored || v || (v = Q)
          }
        }
      }
    for (B = 0; B < D.length; B++) {
      var M = D[B]
      ;(r = M.module), (e = [r])
      try {
        R(r)
      } catch (Q) {
        if ('function' == typeof M.errorHandler)
          try {
            M.errorHandler(Q)
          } catch (F) {
            U.onErrored &&
              U.onErrored({
                type: 'self-accept-error-handler-errored',
                moduleId: r,
                error: F,
                originalError: Q
              }),
              U.ignoreErrored || v || (v = F),
              v || (v = Q)
          }
        else
          U.onErrored && U.onErrored({ type: 'self-accept-errored', moduleId: r, error: Q }),
            U.ignoreErrored || v || (v = Q)
      }
    }
    return v
      ? (i('fail'), Promise.reject(v))
      : (i('idle'),
        new Promise(function(Q) {
          Q(a)
        }))
  }
  var V = {}
  function R(U) {
    if (V[U]) return V[U].exports
    var F = (V[U] = {
      i: U,
      l: !1,
      exports: {},
      hot: r(U),
      parents: ((t = e), (e = []), t),
      children: []
    })
    return Q[U].call(F.exports, F, F.exports, l(U)), (F.l = !0), F.exports
  }
  ;(R.m = Q),
    (R.c = V),
    (R.d = function(Q, U, F) {
      R.o(Q, U) || Object.defineProperty(Q, U, { enumerable: !0, get: F })
    }),
    (R.r = function(Q) {
      'undefined' != typeof Symbol &&
        Symbol.toStringTag &&
        Object.defineProperty(Q, Symbol.toStringTag, { value: 'Module' }),
        Object.defineProperty(Q, '__esModule', { value: !0 })
    }),
    (R.t = function(Q, U) {
      if ((1 & U && (Q = R(Q)), 8 & U)) return Q
      if (4 & U && 'object' == typeof Q && Q && Q.__esModule) return Q
      var F = Object.create(null)
      if (
        (R.r(F),
        Object.defineProperty(F, 'default', { enumerable: !0, value: Q }),
        2 & U && 'string' != typeof Q)
      )
        for (var B in Q)
          R.d(
            F,
            B,
            function(U) {
              return Q[U]
            }.bind(null, B)
          )
      return F
    }),
    (R.n = function(Q) {
      var U =
        Q && Q.__esModule
          ? function() {
              return Q.default
            }
          : function() {
              return Q
            }
      return R.d(U, 'a', U), U
    }),
    (R.o = function(Q, U) {
      return Object.prototype.hasOwnProperty.call(Q, U)
    }),
    (R.p = ''),
    (R.h = function() {
      return n
    }),
    l(3)((R.s = 3))
})([
  ,
  function(module, __webpack_exports__, __webpack_require__) {
    'use strict'
    eval(
      "\n// EXTERNAL MODULE: ./src/polyfills.js\nvar polyfills = __webpack_require__(4);\n\n// CONCATENATED MODULE: ./src/pointers.ts\n/**\r\n * Utilites for working with multiple pointer events\r\n */\r\nfunction findEventIndex(pointers, event) {\r\n    var i = pointers.length;\r\n    while (i--) {\r\n        if (pointers[i].pointerId === event.pointerId) {\r\n            return i;\r\n        }\r\n    }\r\n    return -1;\r\n}\r\nfunction addPointer(pointers, event) {\r\n    var i;\r\n    // Add touches if applicable\r\n    if (event.touches) {\r\n        i = 0;\r\n        for (var _i = 0, _a = event.touches; _i < _a.length; _i++) {\r\n            var touch = _a[_i];\r\n            touch.pointerId = i++;\r\n            addPointer(pointers, touch);\r\n        }\r\n        return;\r\n    }\r\n    i = findEventIndex(pointers, event);\r\n    // Update if already present\r\n    if (i > -1) {\r\n        pointers.splice(i, 1);\r\n    }\r\n    pointers.push(event);\r\n}\r\nfunction removePointer(pointers, event) {\r\n    // Add touches if applicable\r\n    if (event.touches) {\r\n        // Remove all touches\r\n        while (pointers.length) {\r\n            pointers.pop();\r\n        }\r\n        return;\r\n    }\r\n    var i = findEventIndex(pointers, event);\r\n    if (i > -1) {\r\n        pointers.splice(i, 1);\r\n    }\r\n}\r\n/**\r\n * Calculates a center point between\r\n * the given pointer events, for panning\r\n * with multiple pointers.\r\n */\r\nfunction getMiddle(pointers) {\r\n    // Copy to avoid changing by reference\r\n    pointers = pointers.slice(0);\r\n    var event1 = pointers.pop();\r\n    var event2;\r\n    while ((event2 = pointers.pop())) {\r\n        event1 = {\r\n            clientX: (event2.clientX - event1.clientX) / 2 + event1.clientX,\r\n            clientY: (event2.clientY - event1.clientY) / 2 + event1.clientY\r\n        };\r\n    }\r\n    return event1;\r\n}\r\n/**\r\n * Calculates the distance between two points\r\n * for pinch zooming.\r\n * Limits to the first 2\r\n */\r\nfunction getDistance(pointers) {\r\n    if (pointers.length < 2) {\r\n        return 0;\r\n    }\r\n    var event1 = pointers[0];\r\n    var event2 = pointers[1];\r\n    return Math.sqrt(Math.pow(Math.abs(event2.clientX - event1.clientX), 2) +\r\n        Math.pow(Math.abs(event2.clientY - event1.clientY), 2));\r\n}\r\n\n// CONCATENATED MODULE: ./src/events.ts\nvar events;\r\nif (typeof window.PointerEvent === 'function') {\r\n    events = {\r\n        down: 'pointerdown',\r\n        move: 'pointermove',\r\n        up: 'pointerup pointerleave pointercancel'\r\n    };\r\n}\r\nelse if (typeof window.TouchEvent === 'function') {\r\n    events = {\r\n        down: 'touchstart',\r\n        move: 'touchmove',\r\n        up: 'touchend touchcancel'\r\n    };\r\n}\r\nelse {\r\n    events = {\r\n        down: 'mousedown',\r\n        move: 'mousemove',\r\n        up: 'mouseup mouseleave'\r\n    };\r\n}\r\nfunction onPointer(event, elem, handler, eventOpts) {\r\n    events[event].split(' ').forEach(function (name) {\r\n        ;\r\n        elem.addEventListener(name, handler, eventOpts);\r\n    });\r\n}\r\nfunction destroyPointer(event, elem, handler) {\r\n    events[event].split(' ').forEach(function (name) {\r\n        ;\r\n        elem.removeEventListener(name, handler);\r\n    });\r\n}\r\n\n// CONCATENATED MODULE: ./src/css.ts\nvar isIE = !!document.documentMode;\r\n/**\r\n * Proper prefixing for cross-browser compatibility\r\n */\r\nvar divStyle = document.createElement('div').style;\r\nvar prefixes = ['webkit', 'moz', 'ms'];\r\nvar prefixCache = {};\r\nfunction getPrefixedName(name) {\r\n    if (prefixCache[name]) {\r\n        return prefixCache[name];\r\n    }\r\n    if (name in divStyle) {\r\n        return (prefixCache[name] = name);\r\n    }\r\n    var capName = name[0].toUpperCase() + name.slice(1);\r\n    var i = prefixes.length;\r\n    while (i--) {\r\n        var prefixedName = \"\" + prefixes[i] + capName;\r\n        if (prefixedName in divStyle) {\r\n            return (prefixCache[name] = prefixedName);\r\n        }\r\n    }\r\n}\r\n/**\r\n * Gets a style value expected to be a number\r\n */\r\nfunction getCSSNum(name, style) {\r\n    return parseFloat(style[getPrefixedName(name)]) || 0;\r\n}\r\nfunction getBoxStyle(elem, name, style) {\r\n    if (style === void 0) { style = window.getComputedStyle(elem); }\r\n    // Support: FF 68+\r\n    // Firefox requires specificity for border\r\n    var suffix = name === 'border' ? 'Width' : '';\r\n    return {\r\n        left: getCSSNum(name + \"Left\" + suffix, style),\r\n        right: getCSSNum(name + \"Right\" + suffix, style),\r\n        top: getCSSNum(name + \"Top\" + suffix, style),\r\n        bottom: getCSSNum(name + \"Bottom\" + suffix, style)\r\n    };\r\n}\r\n/**\r\n * Set a style using the properly prefixed name\r\n */\r\nfunction setStyle(elem, name, value) {\r\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n    elem.style[getPrefixedName(name)] = value;\r\n}\r\n/**\r\n * Constructs the transition from panzoom options\r\n * and takes care of prefixing the transition and transform\r\n */\r\nfunction setTransition(elem, options) {\r\n    var transform = getPrefixedName('transform');\r\n    setStyle(elem, 'transition', transform + \" \" + options.duration + \"ms \" + options.easing);\r\n}\r\n/**\r\n * Set the transform using the proper prefix\r\n */\r\nfunction setTransform(elem, _a, _) {\r\n    var x = _a.x, y = _a.y, scale = _a.scale, isSVG = _a.isSVG;\r\n    setStyle(elem, 'transform', \"scale(\" + scale + \") translate(\" + x + \"px, \" + y + \"px)\");\r\n    if (isSVG && isIE) {\r\n        var matrixValue = window.getComputedStyle(elem).getPropertyValue('transform');\r\n        elem.setAttribute('transform', matrixValue);\r\n    }\r\n}\r\n/**\r\n * Dimensions used in containment and focal point zooming\r\n */\r\nfunction getDimensions(elem) {\r\n    var parent = elem.parentNode;\r\n    var style = window.getComputedStyle(elem);\r\n    var parentStyle = window.getComputedStyle(parent);\r\n    var rectElem = elem.getBoundingClientRect();\r\n    var rectParent = parent.getBoundingClientRect();\r\n    return {\r\n        elem: {\r\n            style: style,\r\n            width: rectElem.width,\r\n            height: rectElem.height,\r\n            top: rectElem.top,\r\n            bottom: rectElem.bottom,\r\n            left: rectElem.left,\r\n            right: rectElem.right,\r\n            margin: getBoxStyle(elem, 'margin', style),\r\n            border: getBoxStyle(elem, 'border', style)\r\n        },\r\n        parent: {\r\n            style: parentStyle,\r\n            width: rectParent.width,\r\n            height: rectParent.height,\r\n            top: rectParent.top,\r\n            bottom: rectParent.bottom,\r\n            left: rectParent.left,\r\n            right: rectParent.right,\r\n            padding: getBoxStyle(parent, 'padding', parentStyle),\r\n            border: getBoxStyle(parent, 'border', parentStyle)\r\n        }\r\n    };\r\n}\r\n\n// CONCATENATED MODULE: ./src/isAttached.ts\n/**\r\n * Determine if an element is attached to the DOM\r\n * Panzoom requires this so events work properly\r\n */\r\nfunction isAttached(elem) {\r\n    var doc = elem.ownerDocument;\r\n    var parent = elem.parentNode;\r\n    return (doc &&\r\n        parent &&\r\n        doc.nodeType === 9 &&\r\n        parent.nodeType === 1 &&\r\n        doc.documentElement.contains(parent));\r\n}\r\n\n// CONCATENATED MODULE: ./src/isExcluded.ts\nfunction getClass(elem) {\r\n    return (elem.getAttribute('class') || '').trim();\r\n}\r\nfunction hasClass(elem, className) {\r\n    return elem.nodeType === 1 && (\" \" + getClass(elem) + \" \").indexOf(\" \" + className + \" \") > -1;\r\n}\r\nfunction isExcluded(elem, options) {\r\n    for (var cur = elem; cur != null; cur = cur.parentNode) {\r\n        if (hasClass(cur, options.excludeClass) || options.exclude.indexOf(cur) > -1) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}\r\n\n// CONCATENATED MODULE: ./src/isSVGElement.ts\n/**\r\n * Determine if an element is SVG by checking the namespace\r\n * Exception: the <svg> element itself should be treated like HTML\r\n */\r\nvar rsvg = /^http:[\\w\\.\\/]+svg$/;\r\nfunction isSVGElement(elem) {\r\n    return rsvg.test(elem.namespaceURI) && elem.nodeName.toLowerCase() !== 'svg';\r\n}\r\n\n// CONCATENATED MODULE: ./src/shallowClone.ts\nfunction shallowClone(obj) {\r\n    var clone = {};\r\n    for (var key in obj) {\r\n        if (obj.hasOwnProperty(key)) {\r\n            clone[key] = obj[key];\r\n        }\r\n    }\r\n    return clone;\r\n}\r\n\n// CONCATENATED MODULE: ./src/panzoom.ts\nvar __assign = (undefined && undefined.__assign) || function () {\r\n    __assign = Object.assign || function(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\r\n                t[p] = s[p];\r\n        }\r\n        return t;\r\n    };\r\n    return __assign.apply(this, arguments);\r\n};\r\n/**\r\n * Panzoom for panning and zooming elements using CSS transforms\r\n * https://github.com/timmywil/panzoom\r\n *\r\n * Copyright Timmy Willison and other contributors\r\n * Released under the MIT license\r\n * https://github.com/timmywil/panzoom/blob/master/MIT-License.txt\r\n *\r\n */\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nvar defaultOptions = {\r\n    animate: false,\r\n    cursor: 'move',\r\n    disablePan: false,\r\n    disableZoom: false,\r\n    disableXAxis: false,\r\n    disableYAxis: false,\r\n    duration: 200,\r\n    easing: 'ease-in-out',\r\n    exclude: [],\r\n    excludeClass: 'panzoom-exclude',\r\n    handleStartEvent: function (e) {\r\n        e.preventDefault();\r\n        e.stopPropagation();\r\n    },\r\n    maxScale: 4,\r\n    minScale: 0.125,\r\n    overflow: 'hidden',\r\n    panOnlyWhenZoomed: false,\r\n    relative: false,\r\n    setTransform: setTransform,\r\n    startX: 0,\r\n    startY: 0,\r\n    startScale: 1,\r\n    step: 0.3\r\n};\r\nfunction Panzoom(elem, options) {\r\n    if (!elem) {\r\n        throw new Error('Panzoom requires an element as an argument');\r\n    }\r\n    if (elem.nodeType !== 1) {\r\n        throw new Error('Panzoom requires an element with a nodeType of 1');\r\n    }\r\n    if (!isAttached(elem)) {\r\n        throw new Error('Panzoom should be called on elements that have been attached to the DOM');\r\n    }\r\n    options = __assign(__assign({}, defaultOptions), options);\r\n    var isSVG = isSVGElement(elem);\r\n    // Set overflow on the parent\r\n    var parent = elem.parentNode;\r\n    parent.style.overflow = options.overflow;\r\n    parent.style.userSelect = 'none';\r\n    // This is important for mobile to\r\n    // prevent scrolling while panning\r\n    parent.style.touchAction = 'none';\r\n    // Set some default styles on the panzoom element\r\n    elem.style.cursor = options.cursor;\r\n    elem.style.userSelect = 'none';\r\n    elem.style.touchAction = 'none';\r\n    // The default for HTML is '50% 50%'\r\n    // The default for SVG is '0 0'\r\n    // SVG can't be changed in IE\r\n    setStyle(elem, 'transformOrigin', typeof options.origin === 'string' ? options.origin : isSVG ? '0 0' : '50% 50%');\r\n    function setOptions(opts) {\r\n        if (opts === void 0) { opts = {}; }\r\n        for (var key in opts) {\r\n            if (opts.hasOwnProperty(key)) {\r\n                options[key] = opts[key];\r\n            }\r\n        }\r\n        // Handle option side-effects\r\n        if (opts.hasOwnProperty('cursor')) {\r\n            elem.style.cursor = opts.cursor;\r\n        }\r\n        if (opts.hasOwnProperty('overflow')) {\r\n            parent.style.overflow = opts.overflow;\r\n        }\r\n        if (opts.hasOwnProperty('minScale') ||\r\n            opts.hasOwnProperty('maxScale') ||\r\n            opts.hasOwnProperty('contain')) {\r\n            setMinMax();\r\n        }\r\n        if (opts.hasOwnProperty('disablePan')) {\r\n            if (opts.disablePan) {\r\n                destroy();\r\n            }\r\n            else {\r\n                bind();\r\n            }\r\n        }\r\n    }\r\n    var x = 0;\r\n    var y = 0;\r\n    var scale = 1;\r\n    var isPanning = false;\r\n    zoom(options.startScale, { animate: false });\r\n    // Wait for scale to update\r\n    // for accurate dimensions\r\n    // to constrain initial values\r\n    setTimeout(function () {\r\n        setMinMax();\r\n        pan(options.startX, options.startY, { animate: false });\r\n    });\r\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n    function trigger(eventName, detail, opts) {\r\n        if (opts.silent) {\r\n            return;\r\n        }\r\n        var event = new CustomEvent(eventName, { detail: detail });\r\n        elem.dispatchEvent(event);\r\n    }\r\n    function setTransformWithEvent(eventName, opts) {\r\n        var value = { x: x, y: y, scale: scale, isSVG: isSVG };\r\n        requestAnimationFrame(function () {\r\n            if (typeof opts.animate === 'boolean') {\r\n                if (opts.animate) {\r\n                    setTransition(elem, opts);\r\n                }\r\n                else {\r\n                    setStyle(elem, 'transition', 'none');\r\n                }\r\n            }\r\n            opts.setTransform(elem, value, opts);\r\n        });\r\n        trigger(eventName, value, opts);\r\n        trigger('panzoomchange', value, opts);\r\n        return value;\r\n    }\r\n    function setMinMax() {\r\n        if (options.contain) {\r\n            var dims = getDimensions(elem);\r\n            var parentWidth = dims.parent.width - dims.parent.border.left - dims.parent.border.right;\r\n            var parentHeight = dims.parent.height - dims.parent.border.top - dims.parent.border.bottom;\r\n            var elemWidth = dims.elem.width / scale;\r\n            var elemHeight = dims.elem.height / scale;\r\n            var elemScaledWidth = parentWidth / elemWidth;\r\n            var elemScaledHeight = parentHeight / elemHeight;\r\n            if (options.contain === 'inside') {\r\n                options.maxScale = Math.min(elemScaledWidth, elemScaledHeight);\r\n            }\r\n            else if (options.contain === 'outside') {\r\n                options.minScale = Math.max(elemScaledWidth, elemScaledHeight);\r\n            }\r\n        }\r\n    }\r\n    function constrainXY(toX, toY, toScale, panOptions) {\r\n        var opts = __assign(__assign({}, options), panOptions);\r\n        var result = { x: x, y: y, opts: opts };\r\n        if (!opts.force && (opts.disablePan || (opts.panOnlyWhenZoomed && scale === opts.startScale))) {\r\n            return result;\r\n        }\r\n        toX = parseFloat(toX);\r\n        toY = parseFloat(toY);\r\n        if (!opts.disableXAxis) {\r\n            result.x = (opts.relative ? x : 0) + toX;\r\n        }\r\n        if (!opts.disableYAxis) {\r\n            result.y = (opts.relative ? y : 0) + toY;\r\n        }\r\n        if (opts.contain === 'inside') {\r\n            var dims = getDimensions(elem);\r\n            result.x = Math.max(-dims.elem.margin.left - dims.parent.padding.left, Math.min(dims.parent.width -\r\n                dims.elem.width / toScale -\r\n                dims.parent.padding.left -\r\n                dims.elem.margin.left -\r\n                dims.parent.border.left -\r\n                dims.parent.border.right, result.x));\r\n            result.y = Math.max(-dims.elem.margin.top - dims.parent.padding.top, Math.min(dims.parent.height -\r\n                dims.elem.height / toScale -\r\n                dims.parent.padding.top -\r\n                dims.elem.margin.top -\r\n                dims.parent.border.top -\r\n                dims.parent.border.bottom, result.y));\r\n        }\r\n        else if (opts.contain === 'outside') {\r\n            var dims = getDimensions(elem);\r\n            var realWidth = dims.elem.width / scale;\r\n            var realHeight = dims.elem.height / scale;\r\n            var scaledWidth = realWidth * toScale;\r\n            var scaledHeight = realHeight * toScale;\r\n            var diffHorizontal = (scaledWidth - realWidth) / 2;\r\n            var diffVertical = (scaledHeight - realHeight) / 2;\r\n            var minX = (-(scaledWidth - dims.parent.width) -\r\n                dims.parent.padding.left -\r\n                dims.parent.border.left -\r\n                dims.parent.border.right +\r\n                diffHorizontal) /\r\n                toScale;\r\n            var maxX = (diffHorizontal - dims.parent.padding.left) / toScale;\r\n            result.x = Math.max(Math.min(result.x, maxX), minX);\r\n            var minY = (-(scaledHeight - dims.parent.height) -\r\n                dims.parent.padding.top -\r\n                dims.parent.border.top -\r\n                dims.parent.border.bottom +\r\n                diffVertical) /\r\n                toScale;\r\n            var maxY = (diffVertical - dims.parent.padding.top) / toScale;\r\n            result.y = Math.max(Math.min(result.y, maxY), minY);\r\n        }\r\n        return result;\r\n    }\r\n    function constrainScale(toScale, zoomOptions) {\r\n        var opts = __assign(__assign({}, options), zoomOptions);\r\n        var result = { scale: scale, opts: opts };\r\n        if (!opts.force && opts.disableZoom) {\r\n            return result;\r\n        }\r\n        result.scale = Math.min(Math.max(toScale, opts.minScale), opts.maxScale);\r\n        return result;\r\n    }\r\n    function pan(toX, toY, panOptions) {\r\n        var result = constrainXY(toX, toY, scale, panOptions);\r\n        var opts = result.opts;\r\n        x = result.x;\r\n        y = result.y;\r\n        return setTransformWithEvent('panzoompan', opts);\r\n    }\r\n    function zoom(toScale, zoomOptions) {\r\n        var result = constrainScale(toScale, zoomOptions);\r\n        var opts = result.opts;\r\n        if (!opts.force && opts.disableZoom) {\r\n            return;\r\n        }\r\n        toScale = result.scale;\r\n        var toX = x;\r\n        var toY = y;\r\n        if (opts.focal) {\r\n            // The difference between the point after the scale and the point before the scale\r\n            // plus the current translation after the scale\r\n            // neutralized to no scale (as the transform scale will apply to the translation)\r\n            var focal = opts.focal;\r\n            toX = (focal.x / toScale - focal.x / scale + x * toScale) / toScale;\r\n            toY = (focal.y / toScale - focal.y / scale + y * toScale) / toScale;\r\n        }\r\n        var panResult = constrainXY(toX, toY, toScale, { relative: false, force: true });\r\n        x = panResult.x;\r\n        y = panResult.y;\r\n        scale = toScale;\r\n        return setTransformWithEvent('panzoomzoom', opts);\r\n    }\r\n    function zoomInOut(isIn, zoomOptions) {\r\n        var opts = __assign(__assign(__assign({}, options), { animate: true }), zoomOptions);\r\n        return zoom(scale * Math.exp((isIn ? 1 : -1) * opts.step), opts);\r\n    }\r\n    function zoomIn(zoomOptions) {\r\n        return zoomInOut(true, zoomOptions);\r\n    }\r\n    function zoomOut(zoomOptions) {\r\n        return zoomInOut(false, zoomOptions);\r\n    }\r\n    function zoomToPoint(toScale, point, zoomOptions) {\r\n        var dims = getDimensions(elem);\r\n        // Instead of thinking of operating on the panzoom element,\r\n        // think of operating on the area inside the panzoom\r\n        // element's parent\r\n        // Subtract padding and border\r\n        var effectiveArea = {\r\n            width: dims.parent.width -\r\n                dims.parent.padding.left -\r\n                dims.parent.padding.right -\r\n                dims.parent.border.left -\r\n                dims.parent.border.right,\r\n            height: dims.parent.height -\r\n                dims.parent.padding.top -\r\n                dims.parent.padding.bottom -\r\n                dims.parent.border.top -\r\n                dims.parent.border.bottom\r\n        };\r\n        // Adjust the clientX/clientY to ignore the area\r\n        // outside the effective area\r\n        var clientX = point.clientX -\r\n            dims.parent.left -\r\n            dims.parent.padding.left -\r\n            dims.parent.border.left -\r\n            dims.elem.margin.left;\r\n        var clientY = point.clientY -\r\n            dims.parent.top -\r\n            dims.parent.padding.top -\r\n            dims.parent.border.top -\r\n            dims.elem.margin.top;\r\n        // Adjust the clientX/clientY for HTML elements,\r\n        // because they have a transform-origin of 50% 50%\r\n        if (!isSVG) {\r\n            clientX -= dims.elem.width / scale / 2;\r\n            clientY -= dims.elem.height / scale / 2;\r\n        }\r\n        // Convert the mouse point from it's position over the\r\n        // effective area before the scale to the position\r\n        // over the effective area after the scale.\r\n        var focal = {\r\n            x: (clientX / effectiveArea.width) * (effectiveArea.width * toScale),\r\n            y: (clientY / effectiveArea.height) * (effectiveArea.height * toScale)\r\n        };\r\n        return zoom(toScale, __assign(__assign({ animate: false }, zoomOptions), { focal: focal }));\r\n    }\r\n    function zoomWithWheel(event, zoomOptions) {\r\n        // Need to prevent the default here\r\n        // or it conflicts with regular page scroll\r\n        event.preventDefault();\r\n        var opts = __assign(__assign({}, options), zoomOptions);\r\n        // Normalize to deltaX in case shift modifier is used on Mac\r\n        var delta = event.deltaY === 0 && event.deltaX ? event.deltaX : event.deltaY;\r\n        var wheel = delta < 0 ? 1 : -1;\r\n        var toScale = constrainScale(scale * Math.exp((wheel * opts.step) / 3), opts).scale;\r\n        return zoomToPoint(toScale, event, opts);\r\n    }\r\n    function reset(resetOptions) {\r\n        var opts = __assign(__assign(__assign({}, options), { animate: true, force: true }), resetOptions);\r\n        scale = constrainScale(opts.startScale, opts).scale;\r\n        var panResult = constrainXY(opts.startX, opts.startY, scale, opts);\r\n        x = panResult.x;\r\n        y = panResult.y;\r\n        return setTransformWithEvent('panzoomreset', opts);\r\n    }\r\n    var origX;\r\n    var origY;\r\n    var startClientX;\r\n    var startClientY;\r\n    var startScale;\r\n    var startDistance;\r\n    var pointers = [];\r\n    function handleDown(event) {\r\n        // Don't handle this event if the target is excluded\r\n        if (isExcluded(event.target, options)) {\r\n            return;\r\n        }\r\n        addPointer(pointers, event);\r\n        isPanning = true;\r\n        options.handleStartEvent(event);\r\n        origX = x;\r\n        origY = y;\r\n        trigger('panzoomstart', { x: x, y: y, scale: scale }, options);\r\n        // This works whether there are multiple\r\n        // pointers or not\r\n        var point = getMiddle(pointers);\r\n        startClientX = point.clientX;\r\n        startClientY = point.clientY;\r\n        startScale = scale;\r\n        startDistance = getDistance(pointers);\r\n    }\r\n    function move(event) {\r\n        if (!isPanning ||\r\n            origX === undefined ||\r\n            origY === undefined ||\r\n            startClientX === undefined ||\r\n            startClientY === undefined) {\r\n            return;\r\n        }\r\n        addPointer(pointers, event);\r\n        var current = getMiddle(pointers);\r\n        if (pointers.length > 1) {\r\n            // Use the distance between the first 2 pointers\r\n            // to determine the current scale\r\n            var diff = getDistance(pointers) - startDistance;\r\n            var toScale = constrainScale((diff * options.step) / 80 + startScale).scale;\r\n            zoomToPoint(toScale, current);\r\n        }\r\n        pan(origX + (current.clientX - startClientX) / scale, origY + (current.clientY - startClientY) / scale, {\r\n            animate: false\r\n        });\r\n    }\r\n    function handleUp(event) {\r\n        // Don't call panzoomend when panning with 2 touches\r\n        // until both touches end\r\n        if (pointers.length === 1) {\r\n            trigger('panzoomend', { x: x, y: y, scale: scale }, options);\r\n        }\r\n        // Note: don't remove all pointers\r\n        // Can restart without having to reinitiate all of them\r\n        // Remove the pointer regardless of the isPanning state\r\n        removePointer(pointers, event);\r\n        if (!isPanning) {\r\n            return;\r\n        }\r\n        isPanning = false;\r\n        origX = origY = startClientX = startClientY = undefined;\r\n    }\r\n    function bind() {\r\n        onPointer('down', elem, handleDown);\r\n        onPointer('move', document, move, { passive: true });\r\n        onPointer('up', document, handleUp, { passive: true });\r\n    }\r\n    function destroy() {\r\n        destroyPointer('down', elem, handleDown);\r\n        destroyPointer('move', document, move);\r\n        destroyPointer('up', document, handleUp);\r\n    }\r\n    if (!options.disablePan) {\r\n        bind();\r\n    }\r\n    return {\r\n        destroy: destroy,\r\n        getPan: function () { return ({ x: x, y: y }); },\r\n        getScale: function () { return scale; },\r\n        getOptions: function () { return shallowClone(options); },\r\n        pan: pan,\r\n        reset: reset,\r\n        setOptions: setOptions,\r\n        setStyle: function (name, value) { return setStyle(elem, name, value); },\r\n        zoom: zoom,\r\n        zoomIn: zoomIn,\r\n        zoomOut: zoomOut,\r\n        zoomToPoint: zoomToPoint,\r\n        zoomWithWheel: zoomWithWheel\r\n    };\r\n}\r\nPanzoom.defaultOptions = defaultOptions;\r\n/* harmony default export */ var panzoom = __webpack_exports__[\"a\"] = (Panzoom);\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvcG9pbnRlcnMudHM/ZDA1OCIsIndlYnBhY2s6Ly8vLi9zcmMvZXZlbnRzLnRzPzA1ZDEiLCJ3ZWJwYWNrOi8vLy4vc3JjL2Nzcy50cz84MTQzIiwid2VicGFjazovLy8uL3NyYy9pc0F0dGFjaGVkLnRzP2EwM2IiLCJ3ZWJwYWNrOi8vLy4vc3JjL2lzRXhjbHVkZWQudHM/NTQzMiIsIndlYnBhY2s6Ly8vLi9zcmMvaXNTVkdFbGVtZW50LnRzPzQ2MjgiLCJ3ZWJwYWNrOi8vLy4vc3JjL3NoYWxsb3dDbG9uZS50cz9lNDc2Iiwid2VicGFjazovLy8uL3NyYy9wYW56b29tLnRzP2I4ZjQiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQTs7R0FFRztBQUVILFNBQVMsY0FBYyxDQUFDLFFBQXdCLEVBQUUsS0FBbUI7SUFDbkUsSUFBSSxDQUFDLEdBQUcsUUFBUSxDQUFDLE1BQU07SUFDdkIsT0FBTyxDQUFDLEVBQUUsRUFBRTtRQUNWLElBQUksUUFBUSxDQUFDLENBQUMsQ0FBQyxDQUFDLFNBQVMsS0FBSyxLQUFLLENBQUMsU0FBUyxFQUFFO1lBQzdDLE9BQU8sQ0FBQztTQUNUO0tBQ0Y7SUFDRCxPQUFPLENBQUMsQ0FBQztBQUNYLENBQUM7QUFFTSxTQUFTLFVBQVUsQ0FBQyxRQUF3QixFQUFFLEtBQW1CO0lBQ3RFLElBQUksQ0FBQztJQUNMLDRCQUE0QjtJQUM1QixJQUFLLEtBQWEsQ0FBQyxPQUFPLEVBQUU7UUFDMUIsQ0FBQyxHQUFHLENBQUM7UUFDTCxLQUFvQixVQUFzQixFQUF0QixLQUFDLEtBQWEsQ0FBQyxPQUFPLEVBQXRCLGNBQXNCLEVBQXRCLElBQXNCLEVBQUU7WUFBdkMsSUFBTSxLQUFLO1lBQ2QsS0FBSyxDQUFDLFNBQVMsR0FBRyxDQUFDLEVBQUU7WUFDckIsVUFBVSxDQUFDLFFBQVEsRUFBRSxLQUFLLENBQUM7U0FDNUI7UUFDRCxPQUFNO0tBQ1A7SUFDRCxDQUFDLEdBQUcsY0FBYyxDQUFDLFFB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QXFCO1FBQ3ZDLEdBQUc7UUFDSCxLQUFLO1FBQ0wsVUFBVTtRQUNWLFFBQVEsRUFBRSxVQUFDLElBQVksRUFBRSxLQUFhLElBQUssZUFBUSxDQUFDLElBQUksRUFBRSxJQUFJLEVBQUUsS0FBSyxDQUFDLEVBQTNCLENBQTJCO1FBQ3RFLElBQUk7UUFDSixNQUFNO1FBQ04sT0FBTztRQUNQLFdBQVc7UUFDWCxhQUFhO0tBQ2Q7QUFDSCxDQUFDO0FBRUQsT0FBTyxDQUFDLGNBQWMsR0FBRyxjQUFjO0FBRXhCLDhFQUFPIiwiZmlsZSI6IjEuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIFV0aWxpdGVzIGZvciB3b3JraW5nIHdpdGggbXVsdGlwbGUgcG9pbnRlciBldmVudHNcbiAqL1xuXG5mdW5jdGlvbiBmaW5kRXZlbnRJbmRleChwb2ludGVyczogUG9pbnRlckV2ZW50W10sIGV2ZW50OiBQb2ludGVyRXZlbnQpIHtcbiAgbGV0IGkgPSBwb2ludGVycy5sZW5ndGhcbiAgd2hpbGUgKGktLSkge1xuICAgIGlmIChwb2ludGVyc1tpXS5wb2ludGVySWQgPT09IGV2ZW50LnBvaW50ZXJJZCkge1xuICAgICAgcmV0dXJuIGlcbiAgICB9XG4gIH1cbiAgcmV0dXJuIC0xXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhZGRQb2ludGVyKHBvaW50ZXJzOiBQb2ludGVyRXZlbnRbXSwgZXZlbnQ6IFBvaW50ZXJFdmVudCkge1xuICBsZXQgaVxuICAvLyBBZGQgdG91Y2hlcyBpZiBhcHBsaWNhYmxlXG4gIGlmICgoZXZlbnQgYXMgYW55KS50b3VjaGVzKSB7XG4gICAgaSA9IDBcbiAgICBmb3IgKGNvbnN0IHRvdWNoIG9mIChldmVudCBhcyBhbnkpLnRvdWNoZXMpIHtcbiAgICAgIHRvdWNoLnBvaW50ZXJJZCA9IGkrK1xuICAgICAgYWRkUG9pbnRlcihwb2ludGVycywgdG91Y2gpXG4gICAgfVxuICAgIHJldHVyblxuICB9XG4gIGkgPSBmaW5kRXZlbnRJbmRleChwb2ludGVycywgZXZlbnQpXG4gIC8vIFVwZGF0ZSBpZiBhbHJlYWR5IHByZXNlbnRcbiAgaWYgKGkgPiAtMSkge1xuICAgIHBvaW50ZXJzLnNwbGljZShpLCAxKVxuICB9XG4gIHBvaW50ZXJzLnB1c2goZXZlbnQpXG59XG5cbmV4cG9ydCBmdW5jdGlvbiByZW1vdmVQb2ludGVyKHBvaW50ZXJzOiBQb2ludGVyRXZlbnRbXSwgZXZlbnQ6IFBvaW50ZXJFdmVudCkge1xuICAvLyBBZGQgdG91Y2hlcyBpZiBhcHBsaWNhYmxlXG4gIGlmICgoZXZlbnQgYXMgYW55KS50b3VjaGVzKSB7XG4gICAgLy8gUmVtb3ZlIGFsbCB0b3VjaGVzXG4gICAgd2hpbGUgKHBvaW50ZXJzLmxlbmd0aCkge1xuICAgICAgcG9pbnRlcnMucG9wKClcbiAgICB9XG4gICAgcmV0dXJuXG4gIH1cbiAgY29uc3QgaSA9IGZpbmRFdmVudEluZGV4KHBvaW50ZXJzLCBldmVudClcbiAgaWYgKGkgPiAtMSkge1xuICAgIHBvaW50ZXJzLnNwbGljZShpLCAxKVxuICB9XG59XG5cbi8qKlxuICogQ2FsY3VsYXRlcyBhIGNlbnRlciBwb2ludCBiZXR3ZWVuXG4gKiB0aGUgZ2l2ZW4gcG9pbnRlciBldmVudHMsIGZvciBwYW5uaW5nXG4gKiB3aXRoIG11bHRpcGxlIHBvaW50ZXJzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0TWlkZGxlKHBvaW50ZXJzOiBQb2ludGVyRXZlbnRbXSkge1xuICAvLyBDb3B5IHRvIGF2b2lkIGNoYW5naW5nIGJ5IHJlZmVyZW5jZVxuICBwb2ludGVycyA9IHBvaW50ZXJzLnNsaWNlKDApXG4gIGxldCBldmVudDE6IFBpY2s8UG9pbnRlckV2ZW50LCAnY2xpZW50WCcgfCAnY2xpZW50WSc+ID0gcG9pbnRlcnMucG9wKClcbiAgbGV0IGV2ZW50MjogUG9pbnRlckV2ZW50XG4gIHdoaWxlICgoZXZlbnQyID0gcG9pbnRlcnMucG9wKCkpKSB7XG4gICAgZXZlbnQxID0ge1xuICAgICAgY2xpZW50WDogKGV2ZW50Mi5jbGllbnRYIC0gZXZlbnQxLmNsaWVudFgpIC8gMiArIGV2ZW50MS5jbGllbnRYLFxuICAgICAgY2xpZW50WTogKGV2ZW50Mi5jbGllbnRZIC0gZXZlbnQxLmNsaWVudFkpIC8gMiArIGV2ZW50MS5jbGllbnRZXG4gICAgfVxuICB9XG4gIHJldHVybiBldmVudDFcbn1cblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBkaXN0YW5jZSBiZXR3ZWVuIHR3byBwb2ludHNcbiAqIGZvciBwaW5jaCB6b29taW5nLlxuICogTGltaXRzIHRvIHRoZSBmaXJzdCAyXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXREaXN0YW5jZShwb2ludGVyczogUG9pbnRlckV2ZW50W10pIHtcbiAgaWYgKHBvaW50ZXJzLmxlbmd0aCA8IDIpIHtcbiAgICByZXR1cm4gMFxuICB9XG4gIGNvbnN0IGV2ZW50MSA9IHBvaW50ZXJzWzBdXG4gIGNvbnN0IGV2ZW50MiA9IHBvaW50ZXJzWzFdXG4gIHJldHVybiBNYXRoLnNxcnQoXG4gICAgTWF0aC5wb3coTWF0aC5hYnMoZXZlbnQyLmNsaWVudFggLSBldmVudDEuY2xpZW50WCksIDIpICtcbiAgICAgIE1hdGgucG93KE1hdGguYWJzKGV2ZW50Mi5jbGllbnRZIC0gZXZlbnQxLmNsaWVudFkpLCAyKVxuICApXG59XG4iLCJsZXQgZXZlbnRzOiB7IGRvd246IHN0cmluZzsgbW92ZTogc3RyaW5nOyB1cDogc3RyaW5nIH1cbmlmICh0eXBlb2YgKHdpbmRvdyBhcyBhbnkpLlBvaW50ZXJFdmVudCA9PT0gJ2Z1bmN0aW9uJykge1xuICBldmVudHMgPSB7XG4gICAgZG93bjogJ3BvaW50ZXJkb3duJyxcbiAgICBtb3ZlOiAncG9pbnRlcm1vdmUnLFxuICAgIHVwOiAncG9pbnRlcnVwIHBvaW50ZXJsZWF2ZSBwb2ludGVyY2FuY2VsJ1xuICB9XG59IGVsc2UgaWYgKHR5cGVvZiAod2luZG93IGFzIGFueSkuVG91Y2hFdmVudCA9PT0gJ2Z1bmN0aW9uJykge1xuICBldmVudHMgPSB7XG4gICAgZG93bjogJ3RvdWNoc3RhcnQnLFxuICAgIG1vdmU6ICd0b3VjaG1vdmUnLFxuICAgIHVwOiAndG91Y2hlbmQgdG91Y2hjYW5jZWwnXG4gIH1cbn0gZWxzZSB7XG4gIGV2ZW50cyA9IHtcbiAgICBkb3duOiAnbW91c2Vkb3duJyxcbiAgICBtb3ZlOiAnbW91c2Vtb3ZlJyxcbiAgICB1cDogJ21vdXNldXAgbW91c2VsZWF2ZSdcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gb25Qb2ludGVyKFxuICBldmVudDogJ2Rvd24nIHwgJ21vdmUnIHwgJ3VwJyxcbiAgZWxlbTogSFRNTEVsZW1lbnQgfCBTVkdFbGVtZW50IHwgRG9jdW1lbnQsXG4gIGhhbmRsZXI6IChldmVudDogUG9pbnRlckV2ZW50KSA9PiB2b2lkLFxuICBldmVudE9wdHM/OiBhbnlcbikge1xuICBldmVudHNbZXZlbnRdLnNwbGl0KCcgJykuZm9yRWFjaCgobmFtZSkgPT4ge1xuICAgIDsoZWxlbSBhcyBIVE1MRWxlbWVudCkuYWRkRXZlbnRMaXN0ZW5lcjxcbiAgICAgICdwb2ludGVyZG93bicgfCAncG9pbnRlcm1vdmUnIHwgJ3BvaW50ZXJ1cCcgfCAncG9pbnRlcmxlYXZlJyB8ICdwb2ludGVyY2FuY2VsJ1xuICAgID4obmFtZSBhcyBhbnksIGhhbmRsZXIsIGV2ZW50T3B0cylcbiAgfSlcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGRlc3Ryb3lQb2ludGVyKFxuICBldmVudDogJ2Rvd24nIHwgJ21vdmUnIHwgJ3VwJyxcbiAgZWxlbTogSFRNTEVsZW1lbnQgfCBTVkdFbGVtZW50IHwgRG9jdW1lbnQsXG4gIGhhbmRsZXI6IChldmVudDogUG9pbnRlckV2ZW50KSA9PiB2b2lkXG4pIHtcbiAgZXZlbnRzW2V2ZW50XS5zcGxpdCgnICcpLmZvckVhY2goKG5hbWUpID0+IHtcbiAgICA7KGVsZW0gYXMgSFRNTEVsZW1lbnQpLnJlbW92ZUV2ZW50TGlzdGVuZXI8XG4gICAgICAncG9pbnRlcmRvd24nIHwgJ3BvaW50ZXJtb3ZlJyB8ICdwb2ludGVydXAnIHwgJ3BvaW50ZXJsZWF2ZScgfCAncG9pbnRlcmNhbmNlbCdcbiAgICA+KG5hbWUgYXMgYW55LCBoYW5kbGVyKVxuICB9KVxufVxuIiwiaW1wb3J0IHsgQ3VycmVudFZhbHVlcywgUGFuem9vbU9wdGlvbnMgfSBmcm9tICcuL3R5cGVzJ1xuXG5jb25zdCBpc0lFID0gISEoZG9jdW1lbnQgYXMgYW55KS5kb2N1bWVudE1vZGVcblxuLyoqXG4gKiBQcm9wZXIgcHJlZml4aW5nIGZvciBjcm9zcy1icm93c2VyIGNvbXBhdGliaWxpdHlcbiAqL1xuY29uc3QgZGl2U3R5bGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKS5zdHlsZVxuY29uc3QgcHJlZml4ZXMgPSBbJ3dlYmtpdCcsICdtb3onLCAnbXMnXVxuY29uc3QgcHJlZml4Q2FjaGU6IHsgW2tleTogc3RyaW5nXTogc3RyaW5nIH0gPSB7fVxuZnVuY3Rpb24gZ2V0UHJlZml4ZWROYW1lKG5hbWU6IHN0cmluZykge1xuICBpZiAocHJlZml4Q2FjaGVbbmFtZV0pIHtcbiAgICByZXR1cm4gcHJlZml4Q2FjaGVbbmFtZV1cbiAgfVxuICBpZiAobmFtZSBpbiBkaXZTdHlsZSkge1xuICAgIHJldHVybiAocHJlZml4Q2FjaGVbbmFtZV0gPSBuYW1lKVxuICB9XG4gIGNvbnN0IGNhcE5hbWUgPSBuYW1lWzBdLnRvVXBwZXJDYXNlKCkgKyBuYW1lLnNsaWNlKDEpXG4gIGxldCBpID0gcHJlZml4ZXMubGVuZ3RoXG4gIHdoaWxlIChpLS0pIHtcbiAgICBjb25zdCBwcmVmaXhlZE5hbWUgPSBgJHtwcmVmaXhlc1tpXX0ke2NhcE5hbWV9YFxuICAgIGlmIChwcmVmaXhlZE5hbWUgaW4gZGl2U3R5bGUpIHtcbiAgICAgIHJldHVybiAocHJlZml4Q2FjaGVbbmFtZV0gPSBwcmVmaXhlZE5hbWUpXG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogR2V0cyBhIHN0eWxlIHZhbHVlIGV4cGVjdGVkIHRvIGJlIGEgbnVtYmVyXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRDU1NOdW0obmFtZTogc3RyaW5nLCBzdHlsZTogQ1NTU3R5bGVEZWNsYXJhdGlvbikge1xuICByZXR1cm4gcGFyc2VGbG9hdChzdHlsZVtnZXRQcmVmaXhlZE5hbWUobmFtZSkgYXMgYW55XSkgfHwgMFxufVxuXG5mdW5jdGlvbiBnZXRCb3hTdHlsZShcbiAgZWxlbTogSFRNTEVsZW1lbnQgfCBTVkdFbGVtZW50LFxuICBuYW1lOiBzdHJpbmcsXG4gIHN0eWxlOiBDU1NTdHlsZURlY2xhcmF0aW9uID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWxlbSlcbikge1xuICAvLyBTdXBwb3J0OiBGRiA2OCtcbiAgLy8gRmlyZWZveCByZXF1aXJlcyBzcGVjaWZpY2l0eSBmb3IgYm9yZGVyXG4gIGNvbnN0IHN1ZmZpeCA9IG5hbWUgPT09ICdib3JkZXInID8gJ1dpZHRoJyA6ICcnXG4gIHJldHVybiB7XG4gICAgbGVmdDogZ2V0Q1NTTnVtKGAke25hbWV9TGVmdCR7c3VmZml4fWAsIHN0eWxlKSxcbiAgICByaWdodDogZ2V0Q1NTTnVtKGAke25hbWV9UmlnaHQke3N1ZmZpeH1gLCBzdHlsZSksXG4gICAgdG9wOiBnZXRDU1NOdW0oYCR7bmFtZX1Ub3Ake3N1ZmZpeH1gLCBzdHlsZSksXG4gICAgYm90dG9tOiBnZXRDU1NOdW0oYCR7bmFtZX1Cb3R0b20ke3N1ZmZpeH1gLCBzdHlsZSlcbiAgfVxufVxuXG4vKipcbiAqIFNldCBhIHN0eWxlIHVzaW5nIHRoZSBwcm9wZXJseSBwcmVmaXhlZCBuYW1lXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzZXRTdHlsZShlbGVtOiBIVE1MRWxlbWVudCB8IFNWR0VsZW1lbnQsIG5hbWU6IHN0cmluZywgdmFsdWU6IHN0cmluZykge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICBlbGVtLnN0eWxlW2dldFByZWZpeGVkTmFtZShuYW1lKSBhcyBhbnldID0gdmFsdWVcbn1cblxuLyoqXG4gKiBDb25zdHJ1Y3RzIHRoZSB0cmFuc2l0aW9uIGZyb20gcGFuem9vbSBvcHRpb25zXG4gKiBhbmQgdGFrZXMgY2FyZSBvZiBwcmVmaXhpbmcgdGhlIHRyYW5zaXRpb24gYW5kIHRyYW5zZm9ybVxuICovXG5leHBvcnQgZnVuY3Rpb24gc2V0VHJhbnNpdGlvbihlbGVtOiBIVE1MRWxlbWVudCB8IFNWR0VsZW1lbnQsIG9wdGlvbnM6IFBhbnpvb21PcHRpb25zKSB7XG4gIGNvbnN0IHRyYW5zZm9ybSA9IGdldFByZWZpeGVkTmFtZSgndHJhbnNmb3JtJylcbiAgc2V0U3R5bGUoZWxlbSwgJ3RyYW5zaXRpb24nLCBgJHt0cmFuc2Zvcm19ICR7b3B0aW9ucy5kdXJhdGlvbn1tcyAke29wdGlvbnMuZWFzaW5nfWApXG59XG5cbi8qKlxuICogU2V0IHRoZSB0cmFuc2Zvcm0gdXNpbmcgdGhlIHByb3BlciBwcmVmaXhcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNldFRyYW5zZm9ybShcbiAgZWxlbTogSFRNTEVsZW1lbnQgfCBTVkdFbGVtZW50LFxuICB7IHgsIHksIHNjYWxlLCBpc1NWRyB9OiBDdXJyZW50VmFsdWVzLFxuICBfPzogUGFuem9vbU9wdGlvbnNcbikge1xuICBzZXRTdHlsZShlbGVtLCAndHJhbnNmb3JtJywgYHNjYWxlKCR7c2NhbGV9KSB0cmFuc2xhdGUoJHt4fXB4LCAke3l9cHgpYClcbiAgaWYgKGlzU1ZHICYmIGlzSUUpIHtcbiAgICBjb25zdCBtYXRyaXhWYWx1ZSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsZW0pLmdldFByb3BlcnR5VmFsdWUoJ3RyYW5zZm9ybScpXG4gICAgZWxlbS5zZXRBdHRyaWJ1dGUoJ3RyYW5zZm9ybScsIG1hdHJpeFZhbHVlKVxuICB9XG59XG5cbi8qKlxuICogRGltZW5zaW9ucyB1c2VkIGluIGNvbnRhaW5tZW50IGFuZCBmb2NhbCBwb2ludCB6b29taW5nXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXREaW1lbnNpb25zKGVsZW06IEhUTUxFbGVtZW50IHwgU1ZHRWxlbWVudCkge1xuICBjb25zdCBwYXJlbnQgPSBlbGVtLnBhcmVudE5vZGUgYXMgSFRNTEVsZW1lbnQgfCBTVkdFbGVtZW50XG4gIGNvbnN0IHN0eWxlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWxlbSlcbiAgY29uc3QgcGFyZW50U3R5bGUgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShwYXJlbnQpXG4gIGNvbnN0IHJlY3RFbGVtID0gZWxlbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKVxuICBjb25zdCByZWN0UGFyZW50ID0gcGFyZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpXG5cbiAgcmV0dXJuIHtcbiAgICBlbGVtOiB7XG4gICAgICBzdHlsZSxcbiAgICAgIHdpZHRoOiByZWN0RWxlbS53aWR0aCxcbiAgICAgIGhlaWdodDogcmVjdEVsZW0uaGVpZ2h0LFxuICAgICAgdG9wOiByZWN0RWxlbS50b3AsXG4gICAgICBib3R0b206IHJlY3RFbGVtLmJvdHRvbSxcbiAgICAgIGxlZnQ6IHJlY3RFbGVtLmxlZnQsXG4gICAgICByaWdodDogcmVjdEVsZW0ucmlnaHQsXG4gICAgICBtYXJnaW46IGdldEJveFN0eWxlKGVsZW0sICdtYXJnaW4nLCBzdHlsZSksXG4gICAgICBib3JkZXI6IGdldEJveFN0eWxlKGVsZW0sICdib3JkZXInLCBzdHlsZSlcbiAgICB9LFxuICAgIHBhcmVudDoge1xuICAgICAgc3R5bGU6IHBhcmVudFN0eWxlLFxuICAgICAgd2lkdGg6IHJlY3RQYXJlbnQud2lkdGgsXG4gICAgICBoZWlnaHQ6IHJlY3RQYXJlbnQuaGVpZ2h0LFxuICAgICAgdG9wOiByZWN0UGFyZW50LnRvcCxcbiAgICAgIGJvdHRvbTogcmVjdFBhcmVudC5ib3R0b20sXG4gICAgICBsZWZ0OiByZWN0UGFyZW50LmxlZnQsXG4gICAgICByaWdodDogcmVjdFBhcmVudC5yaWdodCxcbiAgICAgIHBhZGRpbmc6IGdldEJveFN0eWxlKHBhcmVudCwgJ3BhZGRpbmcnLCBwYXJlbnRTdHlsZSksXG4gICAgICBib3JkZXI6IGdldEJveFN0eWxlKHBhcmVudCwgJ2JvcmRlcicsIHBhcmVudFN0eWxlKVxuICAgIH1cbiAgfVxufVxuIiwiLyoqXG4gKiBEZXRlcm1pbmUgaWYgYW4gZWxlbWVudCBpcyBhdHRhY2hlZCB0byB0aGUgRE9NXG4gKiBQYW56b29tIHJlcXVpcmVzIHRoaXMgc28gZXZlbnRzIHdvcmsgcHJvcGVybHlcbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gaXNBdHRhY2hlZChlbGVtOiBIVE1MRWxlbWVudCB8IFNWR0VsZW1lbnQpIHtcbiAgY29uc3QgZG9jID0gZWxlbS5vd25lckRvY3VtZW50XG4gIGNvbnN0IHBhcmVudCA9IGVsZW0ucGFyZW50Tm9kZVxuICByZXR1cm4gKFxuICAgIGRvYyAmJlxuICAgIHBhcmVudCAmJlxuICAgIGRvYy5ub2RlVHlwZSA9PT0gOSAmJlxuICAgIHBhcmVudC5ub2RlVHlwZSA9PT0gMSAmJlxuICAgIGRvYy5kb2N1bWVudEVsZW1lbnQuY29udGFpbnMocGFyZW50KVxuICApXG59XG4iLCJpbXBvcnQgeyBQYW56b29tT3B0aW9ucyB9IGZyb20gJy4vdHlwZXMnXG5cbmZ1bmN0aW9uIGdldENsYXNzKGVsZW06IEVsZW1lbnQpIHtcbiAgcmV0dXJuIChlbGVtLmdldEF0dHJpYnV0ZSgnY2xhc3MnKSB8fCAnJykudHJpbSgpXG59XG5cbmZ1bmN0aW9uIGhhc0NsYXNzKGVsZW06IEVsZW1lbnQsIGNsYXNzTmFtZTogc3RyaW5nKSB7XG4gIHJldHVybiBlbGVtLm5vZGVUeXBlID09PSAxICYmIGAgJHtnZXRDbGFzcyhlbGVtKX0gYC5pbmRleE9mKGAgJHtjbGFzc05hbWV9IGApID4gLTFcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gaXNFeGNsdWRlZChlbGVtOiBFbGVtZW50LCBvcHRpb25zOiBQYW56b29tT3B0aW9ucykge1xuICBmb3IgKGxldCBjdXIgPSBlbGVtOyBjdXIgIT0gbnVsbDsgY3VyID0gY3VyLnBhcmVudE5vZGUgYXMgRWxlbWVudCkge1xuICAgIGlmIChoYXNDbGFzcyhjdXIsIG9wdGlvbnMuZXhjbHVkZUNsYXNzKSB8fCBvcHRpb25zLmV4Y2x1ZGUuaW5kZXhPZihjdXIpID4gLTEpIHtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZVxufVxuIiwiLyoqXG4gKiBEZXRlcm1pbmUgaWYgYW4gZWxlbWVudCBpcyBTVkcgYnkgY2hlY2tpbmcgdGhlIG5hbWVzcGFjZVxuICogRXhjZXB0aW9uOiB0aGUgPHN2Zz4gZWxlbWVudCBpdHNlbGYgc2hvdWxkIGJlIHRyZWF0ZWQgbGlrZSBIVE1MXG4gKi9cbmNvbnN0IHJzdmcgPSAvXmh0dHA6W1xcd1xcLlxcL10rc3ZnJC9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGlzU1ZHRWxlbWVudChlbGVtOiBIVE1MRWxlbWVudCB8IFNWR0VsZW1lbnQpIHtcbiAgcmV0dXJuIHJzdmcudGVzdChlbGVtLm5hbWVzcGFjZVVSSSkgJiYgZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpICE9PSAnc3ZnJ1xufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gc2hhbGxvd0Nsb25lKG9iajogYW55KSB7XG4gIGNvbnN0IGNsb25lOiBhbnkgPSB7fVxuICBmb3IgKGNvbnN0IGtleSBpbiBvYmopIHtcbiAgICBpZiAob2JqLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgIGNsb25lW2tleV0gPSBvYmpba2V5XVxuICAgIH1cbiAgfVxuICByZXR1cm4gY2xvbmVcbn1cbiIsIi8qKlxuICogUGFuem9vbSBmb3IgcGFubmluZyBhbmQgem9vbWluZyBlbGVtZW50cyB1c2luZyBDU1MgdHJhbnNmb3Jtc1xuICogaHR0cHM6Ly9naXRodWIuY29tL3RpbW15d2lsL3Bhbnpvb21cbiAqXG4gKiBDb3B5cmlnaHQgVGltbXkgV2lsbGlzb24gYW5kIG90aGVyIGNvbnRyaWJ1dG9yc1xuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXG4gKiBodHRwczovL2dpdGh1Yi5jb20vdGltbXl3aWwvcGFuem9vbS9ibG9iL21hc3Rlci9NSVQtTGljZW5zZS50eHRcbiAqXG4gKi9cbmltcG9ydCAnLi9wb2x5ZmlsbHMnXG5cbmltcG9ydCB7IFBhbk9wdGlvbnMsIFBhbnpvb21FdmVudCwgUGFuem9vbU9iamVjdCwgUGFuem9vbU9wdGlvbnMsIFpvb21PcHRpb25zIH0gZnJvbSAnLi90eXBlcydcbmltcG9ydCB7IGFkZFBvaW50ZXIsIGdldERpc3RhbmNlLCBnZXRNaWRkbGUsIHJlbW92ZVBvaW50ZXIgfSBmcm9tICcuL3BvaW50ZXJzJ1xuaW1wb3J0IHsgZGVzdHJveVBvaW50ZXIsIG9uUG9pbnRlciB9IGZyb20gJy4vZXZlbnRzJ1xuaW1wb3J0IHsgZ2V0RGltZW5zaW9ucywgc2V0U3R5bGUsIHNldFRyYW5zZm9ybSwgc2V0VHJhbnNpdGlvbiB9IGZyb20gJy4vY3NzJ1xuXG5pbXBvcnQgaXNBdHRhY2hlZCBmcm9tICcuL2lzQXR0YWNoZWQnXG5pbXBvcnQgaXNFeGNsdWRlZCBmcm9tICcuL2lzRXhjbHVkZWQnXG5pbXBvcnQgaXNTVkdFbGVtZW50IGZyb20gJy4vaXNTVkdFbGVtZW50J1xuaW1wb3J0IHNoYWxsb3dDbG9uZSBmcm9tICcuL3NoYWxsb3dDbG9uZSdcblxuY29uc3QgZGVmYXVsdE9wdGlvbnM6IFBhbnpvb21PcHRpb25zID0ge1xuICBhbmltYXRlOiBmYWxzZSxcbiAgY3Vyc29yOiAnbW92ZScsXG4gIGRpc2FibGVQYW46IGZhbHNlLFxuICBkaXNhYmxlWm9vbTogZmFsc2UsXG4gIGRpc2FibGVYQXhpczogZmFsc2UsXG4gIGRpc2FibGVZQXhpczogZmFsc2UsXG4gIGR1cmF0aW9uOiAyMDAsXG4gIGVhc2luZzogJ2Vhc2UtaW4tb3V0JyxcbiAgZXhjbHVkZTogW10sXG4gIGV4Y2x1ZGVDbGFzczogJ3Bhbnpvb20tZXhjbHVkZScsXG4gIGhhbmRsZVN0YXJ0RXZlbnQ6IChlOiBFdmVudCkgPT4ge1xuICAgIGUucHJldmVudERlZmF1bHQoKVxuICAgIGUuc3RvcFByb3BhZ2F0aW9uKClcbiAgfSxcbiAgbWF4U2NhbGU6IDQsXG4gIG1pblNjYWxlOiAwLjEyNSxcbiAgb3ZlcmZsb3c6ICdoaWRkZW4nLFxuICBwYW5Pbmx5V2hlblpvb21lZDogZmFsc2UsXG4gIHJlbGF0aXZlOiBmYWxzZSxcbiAgc2V0VHJhbnNmb3JtLFxuICBzdGFydFg6IDAsXG4gIHN0YXJ0WTogMCxcbiAgc3RhcnRTY2FsZTogMSxcbiAgc3RlcDogMC4zXG59XG5cbmZ1bmN0aW9uIFBhbnpvb20oXG4gIGVsZW06IEhUTUxFbGVtZW50IHwgU1ZHRWxlbWVudCxcbiAgb3B0aW9ucz86IE9taXQ8UGFuem9vbU9wdGlvbnMsICdmb3JjZSc+XG4pOiBQYW56b29tT2JqZWN0IHtcbiAgaWYgKCFlbGVtKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdQYW56b29tIHJlcXVpcmVzIGFuIGVsZW1lbnQgYXMgYW4gYXJndW1lbnQnKVxuICB9XG4gIGlmIChlbGVtLm5vZGVUeXBlICE9PSAxKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdQYW56b29tIHJlcXVpcmVzIGFuIGVsZW1lbnQgd2l0aCBhIG5vZGVUeXBlIG9mIDEnKVxuICB9XG4gIGlmICghaXNBdHRhY2hlZChlbGVtKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignUGFuem9vbSBzaG91bGQgYmUgY2FsbGVkIG9uIGVsZW1lbnRzIHRoYXQgaGF2ZSBiZWVuIGF0dGFjaGVkIHRvIHRoZSBET00nKVxuICB9XG5cbiAgb3B0aW9ucyA9IHtcbiAgICAuLi5kZWZhdWx0T3B0aW9ucyxcbiAgICAuLi5vcHRpb25zXG4gIH1cblxuICBjb25zdCBpc1NWRyA9IGlzU1ZHRWxlbWVudChlbGVtKVxuXG4gIC8vIFNldCBvdmVyZmxvdyBvbiB0aGUgcGFyZW50XG4gIGNvbnN0IHBhcmVudCA9IGVsZW0ucGFyZW50Tm9kZSBhcyBIVE1MRWxlbWVudCB8IFNWR0VsZW1lbnRcbiAgcGFyZW50LnN0eWxlLm92ZXJmbG93ID0gb3B0aW9ucy5vdmVyZmxvd1xuICBwYXJlbnQuc3R5bGUudXNlclNlbGVjdCA9ICdub25lJ1xuICAvLyBUaGlzIGlzIGltcG9ydGFudCBmb3IgbW9iaWxlIHRvXG4gIC8vIHByZXZlbnQgc2Nyb2xsaW5nIHdoaWxlIHBhbm5pbmdcbiAgcGFyZW50LnN0eWxlLnRvdWNoQWN0aW9uID0gJ25vbmUnXG5cbiAgLy8gU2V0IHNvbWUgZGVmYXVsdCBzdHlsZXMgb24gdGhlIHBhbnpvb20gZWxlbWVudFxuICBlbGVtLnN0eWxlLmN1cnNvciA9IG9wdGlvbnMuY3Vyc29yXG4gIGVsZW0uc3R5bGUudXNlclNlbGVjdCA9ICdub25lJ1xuICBlbGVtLnN0eWxlLnRvdWNoQWN0aW9uID0gJ25vbmUnXG4gIC8vIFRoZSBkZWZhdWx0IGZvciBIVE1MIGlzICc1MCUgNTAlJ1xuICAvLyBUaGUgZGVmYXVsdCBmb3IgU1ZHIGlzICcwIDAnXG4gIC8vIFNWRyBjYW4ndCBiZSBjaGFuZ2VkIGluIElFXG4gIHNldFN0eWxlKFxuICAgIGVsZW0sXG4gICAgJ3RyYW5zZm9ybU9yaWdpbicsXG4gICAgdHlwZW9mIG9wdGlvbnMub3JpZ2luID09PSAnc3RyaW5nJyA/IG9wdGlvbnMub3JpZ2luIDogaXNTVkcgPyAnMCAwJyA6ICc1MCUgNTAlJ1xuICApXG5cbiAgZnVuY3Rpb24gc2V0T3B0aW9ucyhvcHRzOiBPbWl0PFBhbnpvb21PcHRpb25zLCAnZm9yY2UnPiA9IHt9KSB7XG4gICAgZm9yIChjb25zdCBrZXkgaW4gb3B0cykge1xuICAgICAgaWYgKG9wdHMuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICBvcHRpb25zW2tleV0gPSBvcHRzW2tleV1cbiAgICAgIH1cbiAgICB9XG4gICAgLy8gSGFuZGxlIG9wdGlvbiBzaWRlLWVmZmVjdHNcbiAgICBpZiAob3B0cy5oYXNPd25Qcm9wZXJ0eSgnY3Vyc29yJykpIHtcbiAgICAgIGVsZW0uc3R5bGUuY3Vyc29yID0gb3B0cy5jdXJzb3JcbiAgICB9XG4gICAgaWYgKG9wdHMuaGFzT3duUHJvcGVydHkoJ292ZXJmbG93JykpIHtcbiAgICAgIHBhcmVudC5zdHlsZS5vdmVyZmxvdyA9IG9wdHMub3ZlcmZsb3dcbiAgICB9XG4gICAgaWYgKFxuICAgICAgb3B0cy5oYXNPd25Qcm9wZXJ0eSgnbWluU2NhbGUnKSB8fFxuICAgICAgb3B0cy5oYXNPd25Qcm9wZXJ0eSgnbWF4U2NhbGUnKSB8fFxuICAgICAgb3B0cy5oYXNPd25Qcm9wZXJ0eSgnY29udGFpbicpXG4gICAgKSB7XG4gICAgICBzZXRNaW5NYXgoKVxuICAgIH1cbiAgICBpZiAob3B0cy5oYXNPd25Qcm9wZXJ0eSgnZGlzYWJsZVBhbicpKSB7XG4gICAgICBpZiAob3B0cy5kaXNhYmxlUGFuKSB7XG4gICAgICAgIGRlc3Ryb3koKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYmluZCgpXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgbGV0IHggPSAwXG4gIGxldCB5ID0gMFxuICBsZXQgc2NhbGUgPSAxXG4gIGxldCBpc1Bhbm5pbmcgPSBmYWxzZVxuICB6b29tKG9wdGlvbnMuc3RhcnRTY2FsZSwgeyBhbmltYXRlOiBmYWxzZSB9KVxuICAvLyBXYWl0IGZvciBzY2FsZSB0byB1cGRhdGVcbiAgLy8gZm9yIGFjY3VyYXRlIGRpbWVuc2lvbnNcbiAgLy8gdG8gY29uc3RyYWluIGluaXRpYWwgdmFsdWVzXG4gIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgIHNldE1pbk1heCgpXG4gICAgcGFuKG9wdGlvbnMuc3RhcnRYLCBvcHRpb25zLnN0YXJ0WSwgeyBhbmltYXRlOiBmYWxzZSB9KVxuICB9KVxuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gIGZ1bmN0aW9uIHRyaWdnZXIoZXZlbnROYW1lOiBQYW56b29tRXZlbnQsIGRldGFpbDogYW55LCBvcHRzOiBQYW56b29tT3B0aW9ucykge1xuICAgIGlmIChvcHRzLnNpbGVudCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIGNvbnN0IGV2ZW50ID0gbmV3IEN1c3RvbUV2ZW50KGV2ZW50TmFtZSwgeyBkZXRhaWwgfSlcbiAgICBlbGVtLmRpc3BhdGNoRXZlbnQoZXZlbnQpXG4gIH1cblxuICBmdW5jdGlvbiBzZXRUcmFuc2Zvcm1XaXRoRXZlbnQoZXZlbnROYW1lOiBQYW56b29tRXZlbnQsIG9wdHM6IFBhbnpvb21PcHRpb25zKSB7XG4gICAgY29uc3QgdmFsdWUgPSB7IHgsIHksIHNjYWxlLCBpc1NWRyB9XG4gICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgIGlmICh0eXBlb2Ygb3B0cy5hbmltYXRlID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgaWYgKG9wdHMuYW5pbWF0ZSkge1xuICAgICAgICAgIHNldFRyYW5zaXRpb24oZWxlbSwgb3B0cylcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzZXRTdHlsZShlbGVtLCAndHJhbnNpdGlvbicsICdub25lJylcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgb3B0cy5zZXRUcmFuc2Zvcm0oZWxlbSwgdmFsdWUsIG9wdHMpXG4gICAgfSlcbiAgICB0cmlnZ2VyKGV2ZW50TmFtZSwgdmFsdWUsIG9wdHMpXG4gICAgdHJpZ2dlcigncGFuem9vbWNoYW5nZScsIHZhbHVlLCBvcHRzKVxuICAgIHJldHVybiB2YWx1ZVxuICB9XG5cbiAgZnVuY3Rpb24gc2V0TWluTWF4KCkge1xuICAgIGlmIChvcHRpb25zLmNvbnRhaW4pIHtcbiAgICAgIGNvbnN0IGRpbXMgPSBnZXREaW1lbnNpb25zKGVsZW0pXG4gICAgICBjb25zdCBwYXJlbnRXaWR0aCA9IGRpbXMucGFyZW50LndpZHRoIC0gZGltcy5wYXJlbnQuYm9yZGVyLmxlZnQgLSBkaW1zLnBhcmVudC5ib3JkZXIucmlnaHRcbiAgICAgIGNvbnN0IHBhcmVudEhlaWdodCA9IGRpbXMucGFyZW50LmhlaWdodCAtIGRpbXMucGFyZW50LmJvcmRlci50b3AgLSBkaW1zLnBhcmVudC5ib3JkZXIuYm90dG9tXG4gICAgICBjb25zdCBlbGVtV2lkdGggPSBkaW1zLmVsZW0ud2lkdGggLyBzY2FsZVxuICAgICAgY29uc3QgZWxlbUhlaWdodCA9IGRpbXMuZWxlbS5oZWlnaHQgLyBzY2FsZVxuICAgICAgY29uc3QgZWxlbVNjYWxlZFdpZHRoID0gcGFyZW50V2lkdGggLyBlbGVtV2lkdGhcbiAgICAgIGNvbnN0IGVsZW1TY2FsZWRIZWlnaHQgPSBwYXJlbnRIZWlnaHQgLyBlbGVtSGVpZ2h0XG4gICAgICBpZiAob3B0aW9ucy5jb250YWluID09PSAnaW5zaWRlJykge1xuICAgICAgICBvcHRpb25zLm1heFNjYWxlID0gTWF0aC5taW4oZWxlbVNjYWxlZFdpZHRoLCBlbGVtU2NhbGVkSGVpZ2h0KVxuICAgICAgfSBlbHNlIGlmIChvcHRpb25zLmNvbnRhaW4gPT09ICdvdXRzaWRlJykge1xuICAgICAgICBvcHRpb25zLm1pblNjYWxlID0gTWF0aC5tYXgoZWxlbVNjYWxlZFdpZHRoLCBlbGVtU2NhbGVkSGVpZ2h0KVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNvbnN0cmFpblhZKFxuICAgIHRvWDogbnVtYmVyIHwgc3RyaW5nLFxuICAgIHRvWTogbnVtYmVyIHwgc3RyaW5nLFxuICAgIHRvU2NhbGU6IG51bWJlcixcbiAgICBwYW5PcHRpb25zPzogUGFuT3B0aW9uc1xuICApIHtcbiAgICBjb25zdCBvcHRzID0geyAuLi5vcHRpb25zLCAuLi5wYW5PcHRpb25zIH1cbiAgICBjb25zdCByZXN1bHQgPSB7IHgsIHksIG9wdHMgfVxuICAgIGlmICghb3B0cy5mb3JjZSAmJiAob3B0cy5kaXNhYmxlUGFuIHx8IChvcHRzLnBhbk9ubHlXaGVuWm9vbWVkICYmIHNjYWxlID09PSBvcHRzLnN0YXJ0U2NhbGUpKSkge1xuICAgICAgcmV0dXJuIHJlc3VsdFxuICAgIH1cbiAgICB0b1ggPSBwYXJzZUZsb2F0KHRvWCBhcyBzdHJpbmcpXG4gICAgdG9ZID0gcGFyc2VGbG9hdCh0b1kgYXMgc3RyaW5nKVxuXG4gICAgaWYgKCFvcHRzLmRpc2FibGVYQXhpcykge1xuICAgICAgcmVzdWx0LnggPSAob3B0cy5yZWxhdGl2ZSA/IHggOiAwKSArIHRvWFxuICAgIH1cblxuICAgIGlmICghb3B0cy5kaXNhYmxlWUF4aXMpIHtcbiAgICAgIHJlc3VsdC55ID0gKG9wdHMucmVsYXRpdmUgPyB5IDogMCkgKyB0b1lcbiAgICB9XG5cbiAgICBpZiAob3B0cy5jb250YWluID09PSAnaW5zaWRlJykge1xuICAgICAgY29uc3QgZGltcyA9IGdldERpbWVuc2lvbnMoZWxlbSlcbiAgICAgIHJlc3VsdC54ID0gTWF0aC5tYXgoXG4gICAgICAgIC1kaW1zLmVsZW0ubWFyZ2luLmxlZnQgLSBkaW1zLnBhcmVudC5wYWRkaW5nLmxlZnQsXG4gICAgICAgIE1hdGgubWluKFxuICAgICAgICAgIGRpbXMucGFyZW50LndpZHRoIC1cbiAgICAgICAgICAgIGRpbXMuZWxlbS53aWR0aCAvIHRvU2NhbGUgLVxuICAgICAgICAgICAgZGltcy5wYXJlbnQucGFkZGluZy5sZWZ0IC1cbiAgICAgICAgICAgIGRpbXMuZWxlbS5tYXJnaW4ubGVmdCAtXG4gICAgICAgICAgICBkaW1zLnBhcmVudC5ib3JkZXIubGVmdCAtXG4gICAgICAgICAgICBkaW1zLnBhcmVudC5ib3JkZXIucmlnaHQsXG4gICAgICAgICAgcmVzdWx0LnhcbiAgICAgICAgKVxuICAgICAgKVxuICAgICAgcmVzdWx0LnkgPSBNYXRoLm1heChcbiAgICAgICAgLWRpbXMuZWxlbS5tYXJnaW4udG9wIC0gZGltcy5wYXJlbnQucGFkZGluZy50b3AsXG4gICAgICAgIE1hdGgubWluKFxuICAgICAgICAgIGRpbXMucGFyZW50LmhlaWdodCAtXG4gICAgICAgICAgICBkaW1zLmVsZW0uaGVpZ2h0IC8gdG9TY2FsZSAtXG4gICAgICAgICAgICBkaW1zLnBhcmVudC5wYWRkaW5nLnRvcCAtXG4gICAgICAgICAgICBkaW1zLmVsZW0ubWFyZ2luLnRvcCAtXG4gICAgICAgICAgICBkaW1zLnBhcmVudC5ib3JkZXIudG9wIC1cbiAgICAgICAgICAgIGRpbXMucGFyZW50LmJvcmRlci5ib3R0b20sXG4gICAgICAgICAgcmVzdWx0LnlcbiAgICAgICAgKVxuICAgICAgKVxuICAgIH0gZWxzZSBpZiAob3B0cy5jb250YWluID09PSAnb3V0c2lkZScpIHtcbiAgICAgIGNvbnN0IGRpbXMgPSBnZXREaW1lbnNpb25zKGVsZW0pXG4gICAgICBjb25zdCByZWFsV2lkdGggPSBkaW1zLmVsZW0ud2lkdGggLyBzY2FsZVxuICAgICAgY29uc3QgcmVhbEhlaWdodCA9IGRpbXMuZWxlbS5oZWlnaHQgLyBzY2FsZVxuICAgICAgY29uc3Qgc2NhbGVkV2lkdGggPSByZWFsV2lkdGggKiB0b1NjYWxlXG4gICAgICBjb25zdCBzY2FsZWRIZWlnaHQgPSByZWFsSGVpZ2h0ICogdG9TY2FsZVxuICAgICAgY29uc3QgZGlmZkhvcml6b250YWwgPSAoc2NhbGVkV2lkdGggLSByZWFsV2lkdGgpIC8gMlxuICAgICAgY29uc3QgZGlmZlZlcnRpY2FsID0gKHNjYWxlZEhlaWdodCAtIHJlYWxIZWlnaHQpIC8gMlxuICAgICAgY29uc3QgbWluWCA9XG4gICAgICAgICgtKHNjYWxlZFdpZHRoIC0gZGltcy5wYXJlbnQud2lkdGgpIC1cbiAgICAgICAgICBkaW1zLnBhcmVudC5wYWRkaW5nLmxlZnQgLVxuICAgICAgICAgIGRpbXMucGFyZW50LmJvcmRlci5sZWZ0IC1cbiAgICAgICAgICBkaW1zLnBhcmVudC5ib3JkZXIucmlnaHQgK1xuICAgICAgICAgIGRpZmZIb3Jpem9udGFsKSAvXG4gICAgICAgIHRvU2NhbGVcbiAgICAgIGNvbnN0IG1heFggPSAoZGlmZkhvcml6b250YWwgLSBkaW1zLnBhcmVudC5wYWRkaW5nLmxlZnQpIC8gdG9TY2FsZVxuICAgICAgcmVzdWx0LnggPSBNYXRoLm1heChNYXRoLm1pbihyZXN1bHQueCwgbWF4WCksIG1pblgpXG4gICAgICBjb25zdCBtaW5ZID1cbiAgICAgICAgKC0oc2NhbGVkSGVpZ2h0IC0gZGltcy5wYXJlbnQuaGVpZ2h0KSAtXG4gICAgICAgICAgZGltcy5wYXJlbnQucGFkZGluZy50b3AgLVxuICAgICAgICAgIGRpbXMucGFyZW50LmJvcmRlci50b3AgLVxuICAgICAgICAgIGRpbXMucGFyZW50LmJvcmRlci5ib3R0b20gK1xuICAgICAgICAgIGRpZmZWZXJ0aWNhbCkgL1xuICAgICAgICB0b1NjYWxlXG4gICAgICBjb25zdCBtYXhZID0gKGRpZmZWZXJ0aWNhbCAtIGRpbXMucGFyZW50LnBhZGRpbmcudG9wKSAvIHRvU2NhbGVcbiAgICAgIHJlc3VsdC55ID0gTWF0aC5tYXgoTWF0aC5taW4ocmVzdWx0LnksIG1heFkpLCBtaW5ZKVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0XG4gIH1cblxuICBmdW5jdGlvbiBjb25zdHJhaW5TY2FsZSh0b1NjYWxlOiBudW1iZXIsIHpvb21PcHRpb25zPzogWm9vbU9wdGlvbnMpIHtcbiAgICBjb25zdCBvcHRzID0geyAuLi5vcHRpb25zLCAuLi56b29tT3B0aW9ucyB9XG4gICAgY29uc3QgcmVzdWx0ID0geyBzY2FsZSwgb3B0cyB9XG4gICAgaWYgKCFvcHRzLmZvcmNlICYmIG9wdHMuZGlzYWJsZVpvb20pIHtcbiAgICAgIHJldHVybiByZXN1bHRcbiAgICB9XG4gICAgcmVzdWx0LnNjYWxlID0gTWF0aC5taW4oTWF0aC5tYXgodG9TY2FsZSwgb3B0cy5taW5TY2FsZSksIG9wdHMubWF4U2NhbGUpXG4gICAgcmV0dXJuIHJlc3VsdFxuICB9XG5cbiAgZnVuY3Rpb24gcGFuKHRvWDogbnVtYmVyIHwgc3RyaW5nLCB0b1k6IG51bWJlciB8IHN0cmluZywgcGFuT3B0aW9ucz86IFBhbk9wdGlvbnMpIHtcbiAgICBjb25zdCByZXN1bHQgPSBjb25zdHJhaW5YWSh0b1gsIHRvWSwgc2NhbGUsIHBhbk9wdGlvbnMpXG4gICAgY29uc3Qgb3B0cyA9IHJlc3VsdC5vcHRzXG5cbiAgICB4ID0gcmVzdWx0LnhcbiAgICB5ID0gcmVzdWx0LnlcblxuICAgIHJldHVybiBzZXRUcmFuc2Zvcm1XaXRoRXZlbnQoJ3Bhbnpvb21wYW4nLCBvcHRzKVxuICB9XG5cbiAgZnVuY3Rpb24gem9vbSh0b1NjYWxlOiBudW1iZXIsIHpvb21PcHRpb25zPzogWm9vbU9wdGlvbnMpIHtcbiAgICBjb25zdCByZXN1bHQgPSBjb25zdHJhaW5TY2FsZSh0b1NjYWxlLCB6b29tT3B0aW9ucylcbiAgICBjb25zdCBvcHRzID0gcmVzdWx0Lm9wdHNcbiAgICBpZiAoIW9wdHMuZm9yY2UgJiYgb3B0cy5kaXNhYmxlWm9vbSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIHRvU2NhbGUgPSByZXN1bHQuc2NhbGVcbiAgICBsZXQgdG9YID0geFxuICAgIGxldCB0b1kgPSB5XG5cbiAgICBpZiAob3B0cy5mb2NhbCkge1xuICAgICAgLy8gVGhlIGRpZmZlcmVuY2UgYmV0d2VlbiB0aGUgcG9pbnQgYWZ0ZXIgdGhlIHNjYWxlIGFuZCB0aGUgcG9pbnQgYmVmb3JlIHRoZSBzY2FsZVxuICAgICAgLy8gcGx1cyB0aGUgY3VycmVudCB0cmFuc2xhdGlvbiBhZnRlciB0aGUgc2NhbGVcbiAgICAgIC8vIG5ldXRyYWxpemVkIHRvIG5vIHNjYWxlIChhcyB0aGUgdHJhbnNmb3JtIHNjYWxlIHdpbGwgYXBwbHkgdG8gdGhlIHRyYW5zbGF0aW9uKVxuICAgICAgY29uc3QgZm9jYWwgPSBvcHRzLmZvY2FsXG4gICAgICB0b1ggPSAoZm9jYWwueCAvIHRvU2NhbGUgLSBmb2NhbC54IC8gc2NhbGUgKyB4ICogdG9TY2FsZSkgLyB0b1NjYWxlXG4gICAgICB0b1kgPSAoZm9jYWwueSAvIHRvU2NhbGUgLSBmb2NhbC55IC8gc2NhbGUgKyB5ICogdG9TY2FsZSkgLyB0b1NjYWxlXG4gICAgfVxuICAgIGNvbnN0IHBhblJlc3VsdCA9IGNvbnN0cmFpblhZKHRvWCwgdG9ZLCB0b1NjYWxlLCB7IHJlbGF0aXZlOiBmYWxzZSwgZm9yY2U6IHRydWUgfSlcbiAgICB4ID0gcGFuUmVzdWx0LnhcbiAgICB5ID0gcGFuUmVzdWx0LnlcbiAgICBzY2FsZSA9IHRvU2NhbGVcbiAgICByZXR1cm4gc2V0VHJhbnNmb3JtV2l0aEV2ZW50KCdwYW56b29tem9vbScsIG9wdHMpXG4gIH1cblxuICBmdW5jdGlvbiB6b29tSW5PdXQoaXNJbjogYm9vbGVhbiwgem9vbU9wdGlvbnM/OiBab29tT3B0aW9ucykge1xuICAgIGNvbnN0IG9wdHMgPSB7IC4uLm9wdGlvbnMsIGFuaW1hdGU6IHRydWUsIC4uLnpvb21PcHRpb25zIH1cbiAgICByZXR1cm4gem9vbShzY2FsZSAqIE1hdGguZXhwKChpc0luID8gMSA6IC0xKSAqIG9wdHMuc3RlcCksIG9wdHMpXG4gIH1cblxuICBmdW5jdGlvbiB6b29tSW4oem9vbU9wdGlvbnM/OiBab29tT3B0aW9ucykge1xuICAgIHJldHVybiB6b29tSW5PdXQodHJ1ZSwgem9vbU9wdGlvbnMpXG4gIH1cblxuICBmdW5jdGlvbiB6b29tT3V0KHpvb21PcHRpb25zPzogWm9vbU9wdGlvbnMpIHtcbiAgICByZXR1cm4gem9vbUluT3V0KGZhbHNlLCB6b29tT3B0aW9ucylcbiAgfVxuXG4gIGZ1bmN0aW9uIHpvb21Ub1BvaW50KFxuICAgIHRvU2NhbGU6IG51bWJlcixcbiAgICBwb2ludDogeyBjbGllbnRYOiBudW1iZXI7IGNsaWVudFk6IG51bWJlciB9LFxuICAgIHpvb21PcHRpb25zPzogWm9vbU9wdGlvbnNcbiAgKSB7XG4gICAgY29uc3QgZGltcyA9IGdldERpbWVuc2lvbnMoZWxlbSlcblxuICAgIC8vIEluc3RlYWQgb2YgdGhpbmtpbmcgb2Ygb3BlcmF0aW5nIG9uIHRoZSBwYW56b29tIGVsZW1lbnQsXG4gICAgLy8gdGhpbmsgb2Ygb3BlcmF0aW5nIG9uIHRoZSBhcmVhIGluc2lkZSB0aGUgcGFuem9vbVxuICAgIC8vIGVsZW1lbnQncyBwYXJlbnRcbiAgICAvLyBTdWJ0cmFjdCBwYWRkaW5nIGFuZCBib3JkZXJcbiAgICBjb25zdCBlZmZlY3RpdmVBcmVhID0ge1xuICAgICAgd2lkdGg6XG4gICAgICAgIGRpbXMucGFyZW50LndpZHRoIC1cbiAgICAgICAgZGltcy5wYXJlbnQucGFkZGluZy5sZWZ0IC1cbiAgICAgICAgZGltcy5wYXJlbnQucGFkZGluZy5yaWdodCAtXG4gICAgICAgIGRpbXMucGFyZW50LmJvcmRlci5sZWZ0IC1cbiAgICAgICAgZGltcy5wYXJlbnQuYm9yZGVyLnJpZ2h0LFxuICAgICAgaGVpZ2h0OlxuICAgICAgICBkaW1zLnBhcmVudC5oZWlnaHQgLVxuICAgICAgICBkaW1zLnBhcmVudC5wYWRkaW5nLnRvcCAtXG4gICAgICAgIGRpbXMucGFyZW50LnBhZGRpbmcuYm90dG9tIC1cbiAgICAgICAgZGltcy5wYXJlbnQuYm9yZGVyLnRvcCAtXG4gICAgICAgIGRpbXMucGFyZW50LmJvcmRlci5ib3R0b21cbiAgICB9XG5cbiAgICAvLyBBZGp1c3QgdGhlIGNsaWVudFgvY2xpZW50WSB0byBpZ25vcmUgdGhlIGFyZWFcbiAgICAvLyBvdXRzaWRlIHRoZSBlZmZlY3RpdmUgYXJlYVxuICAgIGxldCBjbGllbnRYID1cbiAgICAgIHBvaW50LmNsaWVudFggLVxuICAgICAgZGltcy5wYXJlbnQubGVmdCAtXG4gICAgICBkaW1zLnBhcmVudC5wYWRkaW5nLmxlZnQgLVxuICAgICAgZGltcy5wYXJlbnQuYm9yZGVyLmxlZnQgLVxuICAgICAgZGltcy5lbGVtLm1hcmdpbi5sZWZ0XG4gICAgbGV0IGNsaWVudFkgPVxuICAgICAgcG9pbnQuY2xpZW50WSAtXG4gICAgICBkaW1zLnBhcmVudC50b3AgLVxuICAgICAgZGltcy5wYXJlbnQucGFkZGluZy50b3AgLVxuICAgICAgZGltcy5wYXJlbnQuYm9yZGVyLnRvcCAtXG4gICAgICBkaW1zLmVsZW0ubWFyZ2luLnRvcFxuXG4gICAgLy8gQWRqdXN0IHRoZSBjbGllbnRYL2NsaWVudFkgZm9yIEhUTUwgZWxlbWVudHMsXG4gICAgLy8gYmVjYXVzZSB0aGV5IGhhdmUgYSB0cmFuc2Zvcm0tb3JpZ2luIG9mIDUwJSA1MCVcbiAgICBpZiAoIWlzU1ZHKSB7XG4gICAgICBjbGllbnRYIC09IGRpbXMuZWxlbS53aWR0aCAvIHNjYWxlIC8gMlxuICAgICAgY2xpZW50WSAtPSBkaW1zLmVsZW0uaGVpZ2h0IC8gc2NhbGUgLyAyXG4gICAgfVxuXG4gICAgLy8gQ29udmVydCB0aGUgbW91c2UgcG9pbnQgZnJvbSBpdCdzIHBvc2l0aW9uIG92ZXIgdGhlXG4gICAgLy8gZWZmZWN0aXZlIGFyZWEgYmVmb3JlIHRoZSBzY2FsZSB0byB0aGUgcG9zaXRpb25cbiAgICAvLyBvdmVyIHRoZSBlZmZlY3RpdmUgYXJlYSBhZnRlciB0aGUgc2NhbGUuXG4gICAgY29uc3QgZm9jYWwgPSB7XG4gICAgICB4OiAoY2xpZW50WCAvIGVmZmVjdGl2ZUFyZWEud2lkdGgpICogKGVmZmVjdGl2ZUFyZWEud2lkdGggKiB0b1NjYWxlKSxcbiAgICAgIHk6IChjbGllbnRZIC8gZWZmZWN0aXZlQXJlYS5oZWlnaHQpICogKGVmZmVjdGl2ZUFyZWEuaGVpZ2h0ICogdG9TY2FsZSlcbiAgICB9XG5cbiAgICByZXR1cm4gem9vbSh0b1NjYWxlLCB7IGFuaW1hdGU6IGZhbHNlLCAuLi56b29tT3B0aW9ucywgZm9jYWwgfSlcbiAgfVxuXG4gIGZ1bmN0aW9uIHpvb21XaXRoV2hlZWwoZXZlbnQ6IFdoZWVsRXZlbnQsIHpvb21PcHRpb25zPzogWm9vbU9wdGlvbnMpIHtcbiAgICAvLyBOZWVkIHRvIHByZXZlbnQgdGhlIGRlZmF1bHQgaGVyZVxuICAgIC8vIG9yIGl0IGNvbmZsaWN0cyB3aXRoIHJlZ3VsYXIgcGFnZSBzY3JvbGxcbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpXG5cbiAgICBjb25zdCBvcHRzID0geyAuLi5vcHRpb25zLCAuLi56b29tT3B0aW9ucyB9XG5cbiAgICAvLyBOb3JtYWxpemUgdG8gZGVsdGFYIGluIGNhc2Ugc2hpZnQgbW9kaWZpZXIgaXMgdXNlZCBvbiBNYWNcbiAgICBjb25zdCBkZWx0YSA9IGV2ZW50LmRlbHRhWSA9PT0gMCAmJiBldmVudC5kZWx0YVggPyBldmVudC5kZWx0YVggOiBldmVudC5kZWx0YVlcbiAgICBjb25zdCB3aGVlbCA9IGRlbHRhIDwgMCA/IDEgOiAtMVxuICAgIGNvbnN0IHRvU2NhbGUgPSBjb25zdHJhaW5TY2FsZShzY2FsZSAqIE1hdGguZXhwKCh3aGVlbCAqIG9wdHMuc3RlcCkgLyAzKSwgb3B0cykuc2NhbGVcblxuICAgIHJldHVybiB6b29tVG9Qb2ludCh0b1NjYWxlLCBldmVudCwgb3B0cylcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlc2V0KHJlc2V0T3B0aW9ucz86IFBhbnpvb21PcHRpb25zKSB7XG4gICAgY29uc3Qgb3B0cyA9IHsgLi4ub3B0aW9ucywgYW5pbWF0ZTogdHJ1ZSwgZm9yY2U6IHRydWUsIC4uLnJlc2V0T3B0aW9ucyB9XG4gICAgc2NhbGUgPSBjb25zdHJhaW5TY2FsZShvcHRzLnN0YXJ0U2NhbGUsIG9wdHMpLnNjYWxlXG4gICAgY29uc3QgcGFuUmVzdWx0ID0gY29uc3RyYWluWFkob3B0cy5zdGFydFgsIG9wdHMuc3RhcnRZLCBzY2FsZSwgb3B0cylcbiAgICB4ID0gcGFuUmVzdWx0LnhcbiAgICB5ID0gcGFuUmVzdWx0LnlcbiAgICByZXR1cm4gc2V0VHJhbnNmb3JtV2l0aEV2ZW50KCdwYW56b29tcmVzZXQnLCBvcHRzKVxuICB9XG5cbiAgbGV0IG9yaWdYOiBudW1iZXJcbiAgbGV0IG9yaWdZOiBudW1iZXJcbiAgbGV0IHN0YXJ0Q2xpZW50WDogbnVtYmVyXG4gIGxldCBzdGFydENsaWVudFk6IG51bWJlclxuICBsZXQgc3RhcnRTY2FsZTogbnVtYmVyXG4gIGxldCBzdGFydERpc3RhbmNlOiBudW1iZXJcbiAgY29uc3QgcG9pbnRlcnM6IFBvaW50ZXJFdmVudFtdID0gW11cblxuICBmdW5jdGlvbiBoYW5kbGVEb3duKGV2ZW50OiBQb2ludGVyRXZlbnQpIHtcbiAgICAvLyBEb24ndCBoYW5kbGUgdGhpcyBldmVudCBpZiB0aGUgdGFyZ2V0IGlzIGV4Y2x1ZGVkXG4gICAgaWYgKGlzRXhjbHVkZWQoZXZlbnQudGFyZ2V0IGFzIEVsZW1lbnQsIG9wdGlvbnMpKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgYWRkUG9pbnRlcihwb2ludGVycywgZXZlbnQpXG4gICAgaXNQYW5uaW5nID0gdHJ1ZVxuICAgIG9wdGlvbnMuaGFuZGxlU3RhcnRFdmVudChldmVudClcbiAgICBvcmlnWCA9IHhcbiAgICBvcmlnWSA9IHlcblxuICAgIHRyaWdnZXIoJ3Bhbnpvb21zdGFydCcsIHsgeCwgeSwgc2NhbGUgfSwgb3B0aW9ucylcblxuICAgIC8vIFRoaXMgd29ya3Mgd2hldGhlciB0aGVyZSBhcmUgbXVsdGlwbGVcbiAgICAvLyBwb2ludGVycyBvciBub3RcbiAgICBjb25zdCBwb2ludCA9IGdldE1pZGRsZShwb2ludGVycylcbiAgICBzdGFydENsaWVudFggPSBwb2ludC5jbGllbnRYXG4gICAgc3RhcnRDbGllbnRZID0gcG9pbnQuY2xpZW50WVxuICAgIHN0YXJ0U2NhbGUgPSBzY2FsZVxuICAgIHN0YXJ0RGlzdGFuY2UgPSBnZXREaXN0YW5jZShwb2ludGVycylcbiAgfVxuXG4gIGZ1bmN0aW9uIG1vdmUoZXZlbnQ6IFBvaW50ZXJFdmVudCkge1xuICAgIGlmIChcbiAgICAgICFpc1Bhbm5pbmcgfHxcbiAgICAgIG9yaWdYID09PSB1bmRlZmluZWQgfHxcbiAgICAgIG9yaWdZID09PSB1bmRlZmluZWQgfHxcbiAgICAgIHN0YXJ0Q2xpZW50WCA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICBzdGFydENsaWVudFkgPT09IHVuZGVmaW5lZFxuICAgICkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIGFkZFBvaW50ZXIocG9pbnRlcnMsIGV2ZW50KVxuICAgIGNvbnN0IGN1cnJlbnQgPSBnZXRNaWRkbGUocG9pbnRlcnMpXG4gICAgaWYgKHBvaW50ZXJzLmxlbmd0aCA+IDEpIHtcbiAgICAgIC8vIFVzZSB0aGUgZGlzdGFuY2UgYmV0d2VlbiB0aGUgZmlyc3QgMiBwb2ludGVyc1xuICAgICAgLy8gdG8gZGV0ZXJtaW5lIHRoZSBjdXJyZW50IHNjYWxlXG4gICAgICBjb25zdCBkaWZmID0gZ2V0RGlzdGFuY2UocG9pbnRlcnMpIC0gc3RhcnREaXN0YW5jZVxuICAgICAgY29uc3QgdG9TY2FsZSA9IGNvbnN0cmFpblNjYWxlKChkaWZmICogb3B0aW9ucy5zdGVwKSAvIDgwICsgc3RhcnRTY2FsZSkuc2NhbGVcbiAgICAgIHpvb21Ub1BvaW50KHRvU2NhbGUsIGN1cnJlbnQpXG4gICAgfVxuXG4gICAgcGFuKFxuICAgICAgb3JpZ1ggKyAoY3VycmVudC5jbGllbnRYIC0gc3RhcnRDbGllbnRYKSAvIHNjYWxlLFxuICAgICAgb3JpZ1kgKyAoY3VycmVudC5jbGllbnRZIC0gc3RhcnRDbGllbnRZKSAvIHNjYWxlLFxuICAgICAge1xuICAgICAgICBhbmltYXRlOiBmYWxzZVxuICAgICAgfVxuICAgIClcbiAgfVxuXG4gIGZ1bmN0aW9uIGhhbmRsZVVwKGV2ZW50OiBQb2ludGVyRXZlbnQpIHtcbiAgICAvLyBEb24ndCBjYWxsIHBhbnpvb21lbmQgd2hlbiBwYW5uaW5nIHdpdGggMiB0b3VjaGVzXG4gICAgLy8gdW50aWwgYm90aCB0b3VjaGVzIGVuZFxuICAgIGlmIChwb2ludGVycy5sZW5ndGggPT09IDEpIHtcbiAgICAgIHRyaWdnZXIoJ3Bhbnpvb21lbmQnLCB7IHgsIHksIHNjYWxlIH0sIG9wdGlvbnMpXG4gICAgfVxuICAgIC8vIE5vdGU6IGRvbid0IHJlbW92ZSBhbGwgcG9pbnRlcnNcbiAgICAvLyBDYW4gcmVzdGFydCB3aXRob3V0IGhhdmluZyB0byByZWluaXRpYXRlIGFsbCBvZiB0aGVtXG4gICAgLy8gUmVtb3ZlIHRoZSBwb2ludGVyIHJlZ2FyZGxlc3Mgb2YgdGhlIGlzUGFubmluZyBzdGF0ZVxuICAgIHJlbW92ZVBvaW50ZXIocG9pbnRlcnMsIGV2ZW50KVxuICAgIGlmICghaXNQYW5uaW5nKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgaXNQYW5uaW5nID0gZmFsc2VcbiAgICBvcmlnWCA9IG9yaWdZID0gc3RhcnRDbGllbnRYID0gc3RhcnRDbGllbnRZID0gdW5kZWZpbmVkXG4gIH1cblxuICBmdW5jdGlvbiBiaW5kKCkge1xuICAgIG9uUG9pbnRlcignZG93bicsIGVsZW0sIGhhbmRsZURvd24pXG4gICAgb25Qb2ludGVyKCdtb3ZlJywgZG9jdW1lbnQsIG1vdmUsIHsgcGFzc2l2ZTogdHJ1ZSB9KVxuICAgIG9uUG9pbnRlcigndXAnLCBkb2N1bWVudCwgaGFuZGxlVXAsIHsgcGFzc2l2ZTogdHJ1ZSB9KVxuICB9XG5cbiAgZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICBkZXN0cm95UG9pbnRlcignZG93bicsIGVsZW0sIGhhbmRsZURvd24pXG4gICAgZGVzdHJveVBvaW50ZXIoJ21vdmUnLCBkb2N1bWVudCwgbW92ZSlcbiAgICBkZXN0cm95UG9pbnRlcigndXAnLCBkb2N1bWVudCwgaGFuZGxlVXApXG4gIH1cblxuICBpZiAoIW9wdGlvbnMuZGlzYWJsZVBhbikge1xuICAgIGJpbmQoKVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBkZXN0cm95LFxuICAgIGdldFBhbjogKCkgPT4gKHsgeCwgeSB9KSxcbiAgICBnZXRTY2FsZTogKCkgPT4gc2NhbGUsXG4gICAgZ2V0T3B0aW9uczogKCkgPT4gc2hhbGxvd0Nsb25lKG9wdGlvbnMpLFxuICAgIHBhbixcbiAgICByZXNldCxcbiAgICBzZXRPcHRpb25zLFxuICAgIHNldFN0eWxlOiAobmFtZTogc3RyaW5nLCB2YWx1ZTogc3RyaW5nKSA9PiBzZXRTdHlsZShlbGVtLCBuYW1lLCB2YWx1ZSksXG4gICAgem9vbSxcbiAgICB6b29tSW4sXG4gICAgem9vbU91dCxcbiAgICB6b29tVG9Qb2ludCxcbiAgICB6b29tV2l0aFdoZWVsXG4gIH1cbn1cblxuUGFuem9vbS5kZWZhdWx0T3B0aW9ucyA9IGRlZmF1bHRPcHRpb25zXG5cbmV4cG9ydCBkZWZhdWx0IFBhbnpvb21cbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///1\n"
    )
  },
  ,
  function(module, __webpack_exports__, __webpack_require__) {
    'use strict'
    eval(
      "__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _src_panzoom__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);\n\r\nconsole.log('This is a demo version of Panzoom for testing.');\r\nconsole.log('It exposes a global (window.Panzoom) and should not be used in production.');\r\nwindow.Panzoom = _src_panzoom__WEBPACK_IMPORTED_MODULE_0__[/* default */ \"a\"];\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9kZW1vL2dsb2JhbC1wYW56b29tLnRzPzdiODAiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFvQztBQUVwQyxPQUFPLENBQUMsR0FBRyxDQUFDLGdEQUFnRCxDQUFDO0FBQzdELE9BQU8sQ0FBQyxHQUFHLENBQUMsNEVBQTRFLENBQUM7QUFPekYsTUFBTSxDQUFDLE9BQU8sR0FBRyw0REFBTyIsImZpbGUiOiIzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFBhbnpvb20gZnJvbSAnLi4vc3JjL3Bhbnpvb20nXG5cbmNvbnNvbGUubG9nKCdUaGlzIGlzIGEgZGVtbyB2ZXJzaW9uIG9mIFBhbnpvb20gZm9yIHRlc3RpbmcuJylcbmNvbnNvbGUubG9nKCdJdCBleHBvc2VzIGEgZ2xvYmFsICh3aW5kb3cuUGFuem9vbSkgYW5kIHNob3VsZCBub3QgYmUgdXNlZCBpbiBwcm9kdWN0aW9uLicpXG5cbmRlY2xhcmUgZ2xvYmFsIHtcbiAgaW50ZXJmYWNlIFdpbmRvdyB7XG4gICAgUGFuem9vbTogdHlwZW9mIFBhbnpvb21cbiAgfVxufVxud2luZG93LlBhbnpvb20gPSBQYW56b29tXG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///3\n"
    )
  },
  function(module, exports) {
    eval(
      "/* eslint-disable no-var */\n// Support: IE11 only\nif (window.NodeList && !NodeList.prototype.forEach) {\n  NodeList.prototype.forEach = Array.prototype.forEach\n}\n// Support: IE11 only\n// CustomEvent is an object instead of a constructor\nif (typeof window.CustomEvent !== 'function') {\n  window.CustomEvent = function CustomEvent(event, params) {\n    params = params || { bubbles: false, cancelable: false, detail: null }\n    var evt = document.createEvent('CustomEvent')\n    evt.initCustomEvent(event, params.bubbles, params.cancelable, params.detail)\n    return evt\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvcG9seWZpbGxzLmpzPzA2NzQiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiNC5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qIGVzbGludC1kaXNhYmxlIG5vLXZhciAqL1xuLy8gU3VwcG9ydDogSUUxMSBvbmx5XG5pZiAod2luZG93Lk5vZGVMaXN0ICYmICFOb2RlTGlzdC5wcm90b3R5cGUuZm9yRWFjaCkge1xuICBOb2RlTGlzdC5wcm90b3R5cGUuZm9yRWFjaCA9IEFycmF5LnByb3RvdHlwZS5mb3JFYWNoXG59XG4vLyBTdXBwb3J0OiBJRTExIG9ubHlcbi8vIEN1c3RvbUV2ZW50IGlzIGFuIG9iamVjdCBpbnN0ZWFkIG9mIGEgY29uc3RydWN0b3JcbmlmICh0eXBlb2Ygd2luZG93LkN1c3RvbUV2ZW50ICE9PSAnZnVuY3Rpb24nKSB7XG4gIHdpbmRvdy5DdXN0b21FdmVudCA9IGZ1bmN0aW9uIEN1c3RvbUV2ZW50KGV2ZW50LCBwYXJhbXMpIHtcbiAgICBwYXJhbXMgPSBwYXJhbXMgfHwgeyBidWJibGVzOiBmYWxzZSwgY2FuY2VsYWJsZTogZmFsc2UsIGRldGFpbDogbnVsbCB9XG4gICAgdmFyIGV2dCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdDdXN0b21FdmVudCcpXG4gICAgZXZ0LmluaXRDdXN0b21FdmVudChldmVudCwgcGFyYW1zLmJ1YmJsZXMsIHBhcmFtcy5jYW5jZWxhYmxlLCBwYXJhbXMuZGV0YWlsKVxuICAgIHJldHVybiBldnRcbiAgfVxufVxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///4\n"
    )
  }
])
